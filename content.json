{"meta":{"title":"tfx2001's Blog","subtitle":null,"description":"tfx2001's Blog","author":"tfx2001","url":"https://github.tfx2001.pw"},"pages":[{"title":"About","date":"2019-01-04T08:47:31.000Z","updated":"2019-01-04T08:48:55.925Z","comments":true,"path":"about/index.html","permalink":"https://github.tfx2001.pw/about/index.html","excerpt":"","text":"一个技术宅。"}],"posts":[{"title":"Hello World","slug":"Hello-World-2","date":"2019-01-03T00:42:23.000Z","updated":"2019-01-04T16:08:30.382Z","comments":true,"path":"2019/01/03/Hello-World-2/","link":"","permalink":"https://github.tfx2001.pw/2019/01/03/Hello-World-2/","excerpt":"","text":"算是第三次搭博客了……这次重新回到Github Pages，并换上了Hexo。 希望这次不要再弃坑了吧 周末就把之前的文章搬运过来。","categories":[{"name":"Daily","slug":"Daily","permalink":"https://github.tfx2001.pw/categories/Daily/"}],"tags":[]},{"title":"消失的水街","slug":"消失的水街","date":"2018-04-19T16:00:00.000Z","updated":"2019-01-04T16:51:40.734Z","comments":true,"path":"2018/04/20/消失的水街/","link":"","permalink":"https://github.tfx2001.pw/2018/04/20/消失的水街/","excerpt":"","text":"之前有人和我说我想吃芝麻糊，脑中便冒出水街——南宁美食最多的地方之一，因为在小学的时候我妈就经常带我去水街吃豆腐花、芝麻糊还有粉饺，于是我就打算在三月三期间去一次水街。 在去之前听说水街因为旧城改造搬迁了，在网上查了查发现是真的，但是不知道拆成什么样了，在去之后发现情况远比我想象糟糕得多。 南宁书城 新华路水塔 如今的水街 图中可以看到明显的拆字，但是就在店铺洋之威劳保的门口旁有三块醒目的文物保护标志（具体见下图）。 新会书院 新会书院是南宁市迄今保存最完整，规模最大的清代会馆建筑，已被列为自治区级文物保护单位。 新会书院曾作为同乡聚会，商会议事的活动场所，日常作为学堂使用，供新会商人的后代上学读书，现已成为国家级非物质文化遗产邕剧的传承基地与展示中心，将邕剧艺术与岭南传统建筑完美地融为一体，是南宁和广西历史文化的一个缩影。 精美的屋檐。 水街的美食因为水街搬迁，原先的店铺也搬到了附近的一个政府建设的美食城，其实已经两三年了……尽管美食还是原来的美食，但还是觉得有一些遗憾，毕竟那条承载着老南宁记忆的水街已经变成一片废墟了。 用传统方法现蒸的卷筒粉。 个人认为黄皮酱才是粉饺的精髓（笑。 At Last看着水街变成这样，觉得挺遗憾的，在城市发展的过程中，有越来越多像水街一样的地方消失，最终只存在于一张张的老照片里。希望有关部门能更好地将它们保护起来，而不是拆迁！ 压缩图片与打水印在写文的过程中用到了大量的图片，每张图片原图基本上都有5~6MB，想到用Python的PIL库来处理，剩下的就交给程序就好啦！ 123456789101112131415161718192021222324252627282930313233from PIL import Image, ImageDraw, ImageFontimport os # 指定要使用的字体和大小；/Library/Fonts/是macOS字体目录；Linux的字体目录是/usr/share/fonts/font = ImageFont.truetype('Deng.ttf', 36) # image: 图片 text：要添加的文本 font：字体def add_text_to_image(image, text, font=font): rgba_image = image.convert('RGBA') text_overlay = Image.new('RGBA', rgba_image.size, (255, 255, 255, 0)) image_draw = ImageDraw.Draw(text_overlay) text_size_x, text_size_y = image_draw.textsize(text, font=font) # 设置文本文字位置 print(rgba_image) text_xy = (rgba_image.size[0] - text_size_x - 30, rgba_image.size[1] - text_size_y - 15) # 设置文本颜色和透明度 image_draw.text(text_xy, text, font=font, fill=(0, 0, 0, 70)) image_with_text = Image.alpha_composite(rgba_image, text_overlay) return image_with_textfor fn in os.listdir(): #print(fn.split('.')[1]) if 'JPG' in fn: im_before = Image.open(fn) # 缩放图片 im_before.thumbnail((im_before.size[0] / 3, im_before.size[1] / 3)) im_after = add_text_to_image(im_before, 'Taken by tfx2001.') im_after = im_after.convert('RGB') im_after.save(fn, 'JPEG') print(im_after)","categories":[{"name":"Photography","slug":"Photography","permalink":"https://github.tfx2001.pw/categories/Photography/"}],"tags":[]},{"title":"Hello World","slug":"Hello-World-3","date":"2018-04-14T16:00:00.000Z","updated":"2019-01-04T16:37:38.898Z","comments":true,"path":"2018/04/15/Hello-World-3/","link":"","permalink":"https://github.tfx2001.pw/2018/04/15/Hello-World-3/","excerpt":"","text":"第二次搭博客，这次比上次更新了不少，也花了挺多时间的，但还是有收获吧。 概述这次博客前端框架采用了MDUI（毕竟重度Material Design中毒患者），后端是用Flask框架，nginx为Web服务器，uWSGI作为中间件。 What’s new?这次更新坠重要的就是可以直接在web上写文章，由后端进行Markdown与HTML的转换，再也不需要用Gayhub Page啦！ 本Blog的诞生离不开以下优秀的开源项目 highlight.js MDUI jQuery Flask markdown2 $KaTeX$ markdown-palettes 评论系统 最终还是决定用Disqus，尽管要搭梯子，因为相比起多说（已经凉凉）、畅言，它的后台管理和UI真的很棒。 欢迎各位dalao搭梯子来评论！","categories":[{"name":"Daily","slug":"Daily","permalink":"https://github.tfx2001.pw/categories/Daily/"}],"tags":[]},{"title":"【模板】读入输出优化","slug":"【模板】读入输出优化","date":"2017-11-07T16:00:00.000Z","updated":"2019-01-04T15:47:21.096Z","comments":true,"path":"2017/11/08/【模板】读入输出优化/","link":"","permalink":"https://github.tfx2001.pw/2017/11/08/【模板】读入输出优化/","excerpt":"","text":"在准备复赛的时候，我们的老师说： 你们写读入输出优化的时候，不要乱用网上的那些模板啊，如果爆零就…… 所以，给一个正确的读入输出优化的模板吧。 读入1234567891011121314151617int read() &#123; int ans = 0, flag = 0; //flag用于判负数 char ch = getchar(); while ((ch &lt; '0' || ch &gt; '9') &amp;&amp; ch != '-') ch = getchar(); if (ch == '-') &#123; flag = 1; ch = getchar(); &#125; while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') &#123; ans = ans * 10 + ch - '0'; ch = getchar(); &#125; if (flag) ans = -ans; return ans;&#125; 输出123456789void put(int i) &#123; if (i &lt; 0) &#123; putchar('-'); i = -i; &#125; if (i &gt;= 10) put(i / 10); putchar(i % 10 + '0');&#125;","categories":[{"name":"OI","slug":"OI","permalink":"https://github.tfx2001.pw/categories/OI/"}],"tags":[{"name":"模板","slug":"模板","permalink":"https://github.tfx2001.pw/tags/模板/"},{"name":"读入输出优化","slug":"读入输出优化","permalink":"https://github.tfx2001.pw/tags/读入输出优化/"}]},{"title":"【P1226】取余运算||快速幂","slug":"【P1226】取余运算-快速幂","date":"2017-11-04T16:00:00.000Z","updated":"2019-01-04T15:49:02.798Z","comments":true,"path":"2017/11/05/【P1226】取余运算-快速幂/","link":"","permalink":"https://github.tfx2001.pw/2017/11/05/【P1226】取余运算-快速幂/","excerpt":"","text":"【题目链接】 题目大意输出$\\large b^p \\space mod \\space k$的值。 分析直接朴素算法，边乘边取余，时间复杂度为$O(n)$，数据一大就会TLE…… 我们可以采用倍增的思想，对$b$进行二进制分解，如果前面听不懂也没关系，下面结合具体数字进行讲解。 例如，$3^{11}=177147$，如果我们用朴素算法的话需要做$10$次乘法。$11$的二进制表示为$1011_{(2)}$，所以\\[\\large 3^{11}=3^{2^3+2^1+2^0}=3^{2^{3}} \\times 3^{2^{1}} \\times 3^{2^{0}}\\]最终我们只需要做$3$次乘法，时间复杂度降为$O(log \\space n)$。 代码如下。 代码123456789101112131415161718#include &lt;bits/stdc++.h&gt;using namespace std;int b, p, k;int poww(int a, int b, int mod) &#123; long long ans = 1, base = a; while (b) &#123; if (b &amp; 1) ans = (ans * base) % mod; base *= base; //base一开始是a，那么接下来会变成a^(2^1)，a^(2^2)，a^(2^3)…… base %= mod; b &gt;&gt;= 1; &#125; return ans;&#125;int main() &#123; cin &gt;&gt; b &gt;&gt; p &gt;&gt; k; printf(\"%d^%d mod %d=%d\\n\", b, p, k, poww(b, p, k));&#125;","categories":[{"name":"OI","slug":"OI","permalink":"https://github.tfx2001.pw/categories/OI/"}],"tags":[{"name":"Luogu","slug":"Luogu","permalink":"https://github.tfx2001.pw/tags/Luogu/"},{"name":"快速幂","slug":"快速幂","permalink":"https://github.tfx2001.pw/tags/快速幂/"}]},{"title":"【UVa-11354】Bond","slug":"【UVa-11354】Bond","date":"2017-10-31T16:00:00.000Z","updated":"2019-01-04T15:50:40.038Z","comments":true,"path":"2017/11/01/【UVa-11354】Bond/","link":"","permalink":"https://github.tfx2001.pw/2017/11/01/【UVa-11354】Bond/","excerpt":"","text":"【题目链接】 十一月的第一篇post，本来昨天已经看完倍增了，但后面又去做了一些题巩固一下，今天写一篇post理一下思路。 题目描述有$n$座城市通过$m$条双向道路相连，每一条道路都有一个危险系数。你的任务是回答若干个询问。每个询问包含一个起点$s$和一个终点$t$，要求找一条从$s$到$t$的路，使得途径的所有道路的最大危险系数最小。 分析既然要危险系数最小（先不考虑最大），我们可以先对这个图进行预处理，求出这个图的最小生成树。因为树上两点之间的路径是唯一的，且这条路径肯定会经过这两个点的最近公共祖先，LCA（Least Common Ancestor），找到这条路径之后就可以统计这条路径上危险系数最大的道路了。那么，怎么求LCA呢？ 我们可以打暴力！采用暴力爬链的方式，先要确保两点处于同一深度（如果不在同一深度就把比较深的那个点“提”上来），然后两个点同时一层一层地往上爬，直到两个点相遇，相遇的那个点就是两个点的LCA。这种方法虽然简单，容易理解，但是时间复杂度为$O(n)$……数据一大就很容易超时. 我们可以想优化！这里可以用一种叫做倍增的思想来加速。 倍增，顾名思义，就是成倍地增长，也就是一次爬多层，这样就可以大大加快爬链的速度。实现的方法与快速幂类似，也是用到了二进制展开的方法，时间复杂度变为$O(log \\space n)$。 在求完最小生成树之后，把它转变为有根树（具体细节参见代码），然后进行预处理，处理出$anc$数组和$maxCost$数组，其中，$anc(i,j)$表示的是编号$i$的点向上爬$2^j$层的祖先。$maxCost(i,j)$表示的是$i$号点向上爬$2^j$层的路径中危险系数最大的道路的危险系数。代码如下。 123456789101112131415161718192021222324252627void dfs(int u, int father, int level) &#123; //无根树转有根树 dep[u] = level; int size = G[u].size(); for (int i = 0; i &lt; size; i++) &#123; int v = G[u][i].v; if (v != father) &#123; //关键 fa[v] = u; //节点v的父亲 cost[v] = G[u][i].w; dfs(v, u, level + 1); &#125; &#125;&#125;void preProcess() &#123; for (int i = 1; i &lt;= n; i++) &#123; anc[i][0] = fa[i]; maxCost[i][0] = cost[i]; for (int j = 1; (1 &lt;&lt; j) &lt;= n; j++) anc[i][j] = -1; &#125; for (int j = 1; (1 &lt;&lt; j) &lt;= n; j++) for (int i = 1; i &lt;= n; i++) if (anc[i][j - 1] != -1) &#123; int a = anc[i][j - 1]; anc[i][j] = anc[a][j - 1]; maxCost[i][j] = max(maxCost[i][j - 1], maxCost[a][j - 1]); &#125;&#125; 在预处理完毕之后就可以查询了，代码如下。 12345678910111213141516171819202122232425int query(int p, int q) &#123; int log; if (dep[p] &lt; dep[q]) //确保p比q深 swap(p, q); for (log = 1; (1 &lt;&lt; log) &lt;= dep[p]; log++); log--; int ans = -(1 &lt;&lt; 20); //-INF for (int i = log; i &gt;= 0; i--) //把p往上提 if (dep[p] - (1 &lt;&lt; i) &gt;= dep[q]) &#123; ans = max(ans, maxCost[p][i]); p = anc[p][i]; &#125; if (p == q) //LCA为p或q return ans; for (int i = log; i &gt;= 0; i--) if (anc[p][i] != -1 &amp;&amp; anc[p][i] != anc[q][i]) &#123; ans = max(ans, maxCost[p][i]); p = anc[p][i]; ans = max(ans, maxCost[q][i]); q = anc[q][i]; &#125; ans = max(ans, cost[q]); ans = max(ans, cost[p]); return ans; //LCA为fa[p]或LCA[q]&#125; 代码完整代码。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106#include &lt;bits/stdc++.h&gt;using namespace std;const int MAXN = 50010, MAXM = 100010;struct Edge &#123; int u, v, w; bool operator &lt; (const Edge&amp; b) const &#123; return w &lt; b.w; &#125; Edge (int u = 0, int v = 0, int w = 0) : u(u), v(v), w(w)&#123;&#125;&#125;edge[MAXM];int n, m, fa[MAXN], anc[MAXN][20], dep[MAXN], pa[MAXN], cost[MAXN], maxCost[MAXN][20], kase;vector&lt;Edge&gt; G[MAXN];int getf(int i) &#123; return pa[i] == i ? i : pa[i] = getf(pa[i]); &#125;void dfs(int u, int father, int level) &#123; dep[u] = level; int size = G[u].size(); for (int i = 0; i &lt; size; i++) &#123; int v = G[u][i].v; if (v != father) &#123; fa[v] = u; cost[v] = G[u][i].w; dfs(v, u, level + 1); &#125; &#125;&#125;void preProcess() &#123; for (int i = 1; i &lt;= n; i++) &#123; anc[i][0] = fa[i]; maxCost[i][0] = cost[i]; for (int j = 1; (1 &lt;&lt; j) &lt;= n; j++) anc[i][j] = -1; &#125; for (int j = 1; (1 &lt;&lt; j) &lt;= n; j++) for (int i = 1; i &lt;= n; i++) if (anc[i][j - 1] != -1) &#123; int a = anc[i][j - 1]; anc[i][j] = anc[a][j - 1]; maxCost[i][j] = max(maxCost[i][j - 1], maxCost[a][j - 1]); &#125;&#125;int query(int p, int q) &#123; int log; if (dep[p] &lt; dep[q]) //确保p比q深 swap(p, q); for (log = 1; (1 &lt;&lt; log) &lt;= dep[p]; log++); log--; int ans = -(1 &lt;&lt; 20); for (int i = log; i &gt;= 0; i--) //把p往上提 if (dep[p] - (1 &lt;&lt; i) &gt;= dep[q]) &#123; ans = max(ans, maxCost[p][i]); p = anc[p][i]; &#125; if (p == q) return ans; for (int i = log; i &gt;= 0; i--) if (anc[p][i] != -1 &amp;&amp; anc[p][i] != anc[q][i]) &#123; ans = max(ans, maxCost[p][i]); p = anc[p][i]; ans = max(ans, maxCost[q][i]); q = anc[q][i]; &#125; ans = max(ans, cost[q]); ans = max(ans, cost[p]); return ans;&#125;int main (int argc, char const* argv[]) &#123; while (cin &gt;&gt; n &gt;&gt; m) &#123; if (kase++) cout &lt;&lt; endl; memset(edge, 0, sizeof(edge)); for (int i = 1; i &lt;= n; i++) &#123; pa[i] = i; G[i].clear(); &#125; for (int i = 0; i &lt; m; i++) cin &gt;&gt; edge[i].u &gt;&gt; edge[i].v &gt;&gt; edge[i].w; //最小生成树 sort(edge, edge + m); int cnt = 0; for (int i = 0; i &lt; m; i++) &#123; Edge&amp; e = edge[i]; if (getf(e.u) != getf(e.v)) &#123; pa[getf(e.v)] = getf(e.u); cnt++; G[e.u].push_back(Edge(e.u, e.v, e.w)); G[e.v].push_back(Edge(e.v, e.u, e.w)); if (cnt == n - 1) break; &#125; &#125; //无根树转有根树 dfs(1, -1, 0); preProcess(); int q; cin &gt;&gt; q; int u, v; for (int i = 0; i &lt; q; i++) &#123; cin &gt;&gt; u &gt;&gt; v; cout &lt;&lt; query(u, v) &lt;&lt; endl; &#125; &#125; return 0;&#125; 参考文献[1] 刘汝佳. 算法竞赛入门经典.第2版[M]. 清华大学出版社, 2014.","categories":[{"name":"OI","slug":"OI","permalink":"https://github.tfx2001.pw/categories/OI/"}],"tags":[{"name":"UVa","slug":"UVa","permalink":"https://github.tfx2001.pw/tags/UVa/"},{"name":"倍增","slug":"倍增","permalink":"https://github.tfx2001.pw/tags/倍增/"},{"name":"最近公共祖先，LCA","slug":"最近公共祖先，LCA","permalink":"https://github.tfx2001.pw/tags/最近公共祖先，LCA/"}]},{"title":"【NOIp2014】联合权值","slug":"【NOIp2014】联合权值","date":"2017-10-29T16:00:00.000Z","updated":"2019-01-04T16:02:06.174Z","comments":true,"path":"2017/10/30/【NOIp2014】联合权值/","link":"","permalink":"https://github.tfx2001.pw/2017/10/30/【NOIp2014】联合权值/","excerpt":"","text":"【题目链接】 睡觉前再写一篇文章。 题目大意无向连通图$G$有$n$个点，$n - 1$条边。点从$1$到$n$依次编号，编号为$i$的点的权值为$w_i$，每条边的长度均为$1$。图上两点$(u,\\space v)$的距离定义为$u$点到$v$点的最短距离。对于图$G$上的点对$(u,\\space v)$，若它们的距离为$2$，则它们之间会产生$w_u \\times w_v$的联合权值。 请问图$G$上所有可产生联合权值的有序点对中，联合权值最大的是多少？所有联合权值之和是多少？ 分析我们可以有梦想！别想了，这题并没有梦想分。 我们可以打暴力！题目中提到这个图有$n-1$条边，说明这是一棵无根树 ！只要两个点连接到相同的点就可以产生联合权值。直接在邻接表中暴力枚举每两个点组成的有序点对，累加一下，同时更新最大值。时间复杂度$O(VE)$，期望得分60pts（然而我得了70pts是怎么回事……）。 12345678910111213141516171819202122232425262728293031323334#include &lt;bits/stdc++.h&gt;using namespace std;const int MAXN = 200000 + 5, MOD = 10007;long long n, weight[MAXN];long long ans, max_ans;vector&lt;int&gt; G[MAXN]; //邻接表存图int main (int argc, char const* argv[]) &#123; cin &gt;&gt; n; int u, v; for (int i = 1; i &lt; n; i++) &#123; cin &gt;&gt; u &gt;&gt; v; G[u].push_back(v); G[v].push_back(u); //无向图，加两次边 &#125; for (int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; weight[i]; &#125; for (int i = 1; i &lt;= n; i++) &#123; int size = G[i].size(); for (int j = 0; j &lt; size; j++) &#123; int v1 = G[i][j]; for (int k = 0; k &lt; size; k++) &#123; int v2 = G[i][k]; if (v1 != v2) &#123; ans = (ans + weight[v1] * weight[v2]) % MOD; max_ans = max(max_ans, weight[v1] * weight[v2]); //更新最大值，不能膜！ &#125; &#125; &#125; &#125; cout &lt;&lt; max_ans &lt;&lt; ' ' &lt;&lt; ans &lt;&lt; endl; return 0;&#125; 我们可以想优化！通过观察可以发现，每个邻接表中的某个点$G(i,j)$可以产生的联合权值为：\\[w(i,j) \\times w(i,1) + w(i,j) \\times w(i,2) + … + w(i,j) \\times w(i,k)\\]其中$k$为当前邻接表中点的个数且$k \\neq j$（因为不能自己乘自己）。我们把上面的公式整理一下，变成：\\[w(i,j) \\times (w(i,1) + w(i,2) + … + w(i,3))\\]所以我们可以预处理每个邻接表$G_{i}$中所有点的权值和$\\sum_{j=1}^{k}w(i,j)$，因为$k \\neq i$，所以在计算的时候公式如下：\\[w(i,j) \\times (\\sum_{j=1}^{k}w(i,j)-w(i,j))\\]至于最大最小值，在遍历的过程中不断比较就行。具体细节参见代码。 这个算法的时间复杂度为$O(n)$，期望得分100分。 代码1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;bits/stdc++.h&gt;using namespace std;const int MAXN = 200000 + 5, MOD = 10007;long long n, weight[MAXN], sum[MAXN];long long ans, max_ans;vector&lt;int&gt; G[MAXN];int main (int argc, char const* argv[]) &#123; cin &gt;&gt; n; int u, v; for (int i = 1; i &lt; n; i++) &#123; cin &gt;&gt; u &gt;&gt; v; G[u].push_back(v); G[v].push_back(u); &#125; for (int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; weight[i]; &#125; for (int i = 1; i &lt;= n; i++) &#123; int size = G[i].size(); long long max1 = 0, max2 = 0; //最大值和次大值 for (int j = 0; j &lt; size; j++) &#123; int v = G[i][j]; sum[i] += weight[v]; //更新当前邻接表中所有点的权值的总和 if (weight[v] &gt; max1) &#123; //更新最大值 max2 = max1; max1 = weight[v]; &#125; else if (weight[v] &gt; max2) max2 = weight[v]; &#125; max_ans = max(max_ans, max1 * max2); &#125; for (int i = 1; i &lt;= n; i++) &#123; int size = G[i].size(); for (int j = 0; j &lt; size; j++) &#123; ans = (ans + weight[G[i][j]] * (sum[i] - weight[G[i][j]])) % MOD; //这里别忘了膜 &#125; &#125; cout &lt;&lt; max_ans &lt;&lt; ' ' &lt;&lt; ans &lt;&lt; endl; return 0;&#125;","categories":[{"name":"OI","slug":"OI","permalink":"https://github.tfx2001.pw/categories/OI/"}],"tags":[{"name":"NOIp2014","slug":"NOIp2014","permalink":"https://github.tfx2001.pw/tags/NOIp2014/"},{"name":"动态规划，动规，dp","slug":"动态规划，动规，dp","permalink":"https://github.tfx2001.pw/tags/动态规划，动规，dp/"}]},{"title":"【P1120】小木棍［数据加强版］","slug":"【P1120】小木棍［数据加强版］","date":"2017-10-29T16:00:00.000Z","updated":"2019-01-04T16:00:03.629Z","comments":true,"path":"2017/10/30/【P1120】小木棍［数据加强版］/","link":"","permalink":"https://github.tfx2001.pw/2017/10/30/【P1120】小木棍［数据加强版］/","excerpt":"","text":"【题目链接】 题目大意乔治一开始有一堆同样长的小木棍，然后他把这些木棍随意砍成几段，直到每段的长都不超过50。 现在，他想把小木棍拼接成原来的样子，但是却忘记了自己开始时有多少根木棍和它们的长度。 输出原始木棍的最小可能长度。 分析这是一道搜索题，但是数据范围有点大，需要剪枝，本蒟蒻用到的剪枝如下： 先去掉所有长度$&gt;50$的木棍，然后降序排序，这是为了实现后面的剪枝。 计所有木棍的总长度为$sum$，当前木棍中最长的木棍长度为$a_0$（请参考程序）。 枚举范围为$[a_0,\\space sum]$，计当前枚举到的长度为$len_i$，当且仅当$len_i$为$sum$的因数时开始dfs。 如果$l==t-1$（$l$为当前搜到的第几组木棍），则说明搜到解。 $vis$数组，不用解释了吧？ 如果当前的木棍长度与$s$的和大于$len_i$，则continue。 如果前面同样长度的木棍不合法，那么这当前长度的木棍也肯定不合法。 如果$s==0​$（$s​$为当前组的木棍总长度）且无解，说明后面的木棍不合法，直接返回。 如果$s+a_i==len_i$，说明能组成一组木棍但是无解，说明继续往下搜索已经不可能找到解，返回。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;bits/stdc++.h&gt;using namespace std;const int MAXN = 70;int n, a[MAXN], sum, m, t, cnt;bool vis[MAXN];inline bool dfs(int l, int s, int p) &#123; //p用于减少循环次数 if (s == m) &#123; s = 0; l++; p = 0; &#125; if (l == t - 1) &#123; //剪枝3 return true; &#125; for (register int i = p + 1; i &lt; cnt; i++) &#123; if (s + a[i] &gt; m || vis[i]) //剪枝4和5 continue; if (a[i] == a[i - 1] &amp;&amp; (!vis[i - 1])) //剪枝6 continue; vis[i] = 1; if (dfs(l, s + a[i], i)) return true; vis[i] = 0; if (!s) //剪枝7 return false; if (s + a[i] == m) //剪枝8 return false; &#125; return false;&#125;int main (int argc, char const* argv[]) &#123; cin &gt;&gt; n; cnt = n; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; a[i]; if (a[i] &gt; 50) &#123; //去掉长度大于50的木棍 a[i] = 0; cnt--; &#125; sum += a[i]; &#125; sort(a, a + n, greater&lt;int&gt;()); for (int i = a[0]; i &lt;= sum; i++) &#123; if (!(sum % i)) &#123; //剪枝2 m = i; t = sum / i; if (dfs(0, 0, -1)) &#123; cout &lt;&lt; i &lt;&lt; endl; return 0; &#125; &#125; &#125; return 0;&#125;","categories":[{"name":"OI","slug":"OI","permalink":"https://github.tfx2001.pw/categories/OI/"}],"tags":[{"name":"Luogu","slug":"Luogu","permalink":"https://github.tfx2001.pw/tags/Luogu/"},{"name":"枚举","slug":"枚举","permalink":"https://github.tfx2001.pw/tags/枚举/"},{"name":"搜索","slug":"搜索","permalink":"https://github.tfx2001.pw/tags/搜索/"},{"name":"剪枝","slug":"剪枝","permalink":"https://github.tfx2001.pw/tags/剪枝/"}]},{"title":"【NOIp2016】玩具迷题","slug":"【NOIp2016】玩具迷题","date":"2017-10-24T16:00:00.000Z","updated":"2019-01-04T16:03:29.112Z","comments":true,"path":"2017/10/25/【NOIp2016】玩具迷题/","link":"","permalink":"https://github.tfx2001.pw/2017/10/25/【NOIp2016】玩具迷题/","excerpt":"","text":"【题目链接】 题目大意一群小人围成一圈，你需要按照逆时针或顺时针的方向按顺序数小人，输出最后数到的小人。 分析一道很水的模拟题…… 80pts做法：链表暴力，一步一步模拟，会超时…… 正解：一次走多步，具体细节参见代码。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;string&gt;using namespace std;struct Toy&#123; int cx; //朝向 string name; //名字&#125;toy[100010];struct Cmd&#123; int lr; int num;&#125;cmd[100010];int main()&#123; int n,m; cin&gt;&gt;n&gt;&gt;m; for (int i=1;i&lt;=n;i++)&#123; cin&gt;&gt;toy[i].cx&gt;&gt;toy[i].name; &#125; for (int i=1;i&lt;=m;i++)&#123; scanf(\"%d%d\",&amp;(cmd[i].lr),&amp;(cmd[i].num)); &#125; int p=1; for (int i=1;i&lt;=m;i++)&#123; if(toy[p].cx==0)&#123; if(cmd[i].lr==0)&#123; p-=cmd[i].num; if(p&lt;1) //如果转出圈了，要加上一个n p=n+p; &#125; else&#123; p+=cmd[i].num; if(p&gt;n) //转出圈 p-=n; &#125; &#125; else&#123; if(cmd[i].lr==1)&#123; //另一个朝向 p-=cmd[i].num; if(p&lt;1) p=n+p; &#125; else&#123; p+=cmd[i].num; if(p&gt;n) p-=n; &#125; &#125; &#125; cout&lt;&lt;toy[p].name; return 0;&#125;","categories":[{"name":"OI","slug":"OI","permalink":"https://github.tfx2001.pw/categories/OI/"}],"tags":[{"name":"NOIp2016","slug":"NOIp2016","permalink":"https://github.tfx2001.pw/tags/NOIp2016/"},{"name":"模拟","slug":"模拟","permalink":"https://github.tfx2001.pw/tags/模拟/"}]},{"title":"【NOIp2016】蚯蚓","slug":"【NOIp2016】蚯蚓","date":"2017-10-24T16:00:00.000Z","updated":"2019-01-04T16:05:01.926Z","comments":true,"path":"2017/10/25/【NOIp2016】蚯蚓/","link":"","permalink":"https://github.tfx2001.pw/2017/10/25/【NOIp2016】蚯蚓/","excerpt":"","text":"【题目链接】 题目描述有一群蚯蚓，每一秒，你需要找出最长的那一条并且把它切成两半，并根据参数$t$输出第$t$秒，第$2t$秒，第$3t$秒……被切断蚯蚓（在被切断前）的长度，和$m$秒后蚯蚓的长度；需要按从大到小的顺序，依次输出排名第$t$，第$2t$，第$3t$……的长度。 分析20pts做法：纯模拟……用$O(n)$的时间扫描一遍取出最大值，切成两半，然后全部蚯蚓（除了取出来的）增加长度$q$，最后再把切成的两条蚯蚓放回数组里（当时在赛场上我用的是vector）。最后输出的时候排个序。 80pts做法：既然需要频繁地取出最大值，我们很容易想到（如果这个词伤害了您，我表示深深的歉意）用堆，在这里我用了priority_queue（好像手写堆能得90pts？）。每次取出一条长度最长的蚯蚓，直接pop即可，切成两半后再放回堆里面；输出时就是不断的pop和判断要不要输出。但是还有一个问题：每秒所有蚯蚓（除了被取出的）都要增加长度$q$，如果我们把堆中的元素全部取出来加上长度$q$再放回去，会超时，甚至不如不用堆。既然不能加，那就对于被切成两半的蚯蚓，我们可以减去长度$q$，然后放回堆里。需要注意的是：取出长度一条最长的蚯蚓，这条蚯蚓之前被切过（减去长度$q$），直接对它进行切半是不正确的，因为向下取整时（$\\lfloor c \\rfloor$）会有精度的损失，所以我们需要重新给它加上长度$(t - 1) \\times q$（$t$为当前的时间），最后放回堆时记得减去$(t - 1) \\times q$。具体细节参见代码。 123456789101112131415161718192021222324252627282930313233343536#include &lt;bits/stdc++.h&gt;using namespace std;const int MAXN = 100010;int n, m, q, u, v, t, a[MAXN];double p;priority_queue&lt;int&gt; H;int main() &#123; ios::sync_with_stdio(false); cin &gt;&gt; n &gt;&gt; m &gt;&gt; q &gt;&gt; u &gt;&gt; v &gt;&gt; t; p = (double)u / v; //强制类型转换，不然p会是0 for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; a[i]; H.push(a[i]); //入堆 &#125; for (int i = 1; i &lt;= m; i++) &#123; int len = H.top() + (i - 1) * q; //防止精度误差 H.pop(); if (!(i % t)) //判断要不要输出 cout &lt;&lt; len &lt;&lt; ' '; int len1 = floor(len * p) - (i - 1) * q; int len2 = len - floor(len * p) - (i - 1) * q; H.push(len1 - q); H.push(len2 - q); &#125; cout &lt;&lt; endl; int i = 1; while (!H.empty()) &#123; int ans = H.top(); H.pop(); if (!(i % t)) cout &lt;&lt; ans + q * m &lt;&lt; ' '; i++; &#125; cout &lt;&lt; endl; return 0;&#125; 满分做法：用三个单调队列，分别用来存放没有被切的蚯蚓，切成两半的蚯蚓中长的那一条，切成两半的蚯蚓中短的那一条。为什么要用三个队列来存呢？这是为了保证从三个队列的队首中取出一条最长的蚯蚓一定是所有蚯蚓中最长的，做法和堆差不多。具体细节参见代码。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;bits/stdc++.h&gt;using namespace std;const int MAXN = 100010;int n, m, q, u, v, t, a[MAXN];queue&lt;int&gt; Q, maxQ, minQ;double p;int getMax() &#123; //从三个队列中取出一个最大的数，如果没有数就返回INF int ans = -(1 &lt;&lt; 30), flag = 0;; if (ans &lt; Q.front() &amp;&amp; Q.size()) &#123; ans = Q.front(); flag = 1; &#125; if (ans &lt; maxQ.front() &amp;&amp; maxQ.size()) &#123; ans = maxQ.front(); flag = 2; &#125; if (ans &lt; minQ.front() &amp;&amp; minQ.size()) &#123; ans = minQ.front(); flag = 3; &#125; switch(flag) &#123; case 1: Q.pop(); break; case 2: maxQ.pop(); break; case 3: minQ.pop(); &#125; if (flag == 0) return 1 &lt;&lt; 30; else return ans;&#125;int main (int argc, char const* argv[]) &#123; ios::sync_with_stdio(false); cin &gt;&gt; n &gt;&gt; m &gt;&gt; q &gt;&gt; u &gt;&gt; v &gt;&gt; t; p = (double)u / v; for (int i = 0; i &lt; n; i++) cin &gt;&gt; a[i]; sort(a, a + n, greater&lt;int&gt;()); for (int i = 0; i &lt; n; i++) Q.push(a[i]); for (int i = 1; i &lt;= m; i++) &#123; int len = getMax() + (i - 1) * q; //Q.pop(); if (!(i % t)) cout &lt;&lt; len &lt;&lt; ' '; int len1 = floor(len * p) - (i - 1) * q; int len2 = len - floor(len * p) - (i - 1) * q; maxQ.push(max(len1, len2) - q); minQ.push(min(len1, len2) - q); &#125; cout &lt;&lt; endl; int i = 1, ans; while (ans = getMax()) &#123; if (ans == 1 &lt;&lt; 30) break; if (!(i % t)) cout &lt;&lt; ans + q * m &lt;&lt; ' '; i++; &#125; cout &lt;&lt; endl; return 0;&#125;","categories":[{"name":"OI","slug":"OI","permalink":"https://github.tfx2001.pw/categories/OI/"}],"tags":[{"name":"NOIp2016","slug":"NOIp2016","permalink":"https://github.tfx2001.pw/tags/NOIp2016/"},{"name":"堆","slug":"堆","permalink":"https://github.tfx2001.pw/tags/堆/"},{"name":"队列","slug":"队列","permalink":"https://github.tfx2001.pw/tags/队列/"}]},{"title":"【洛谷10月月赛R2·浴谷八连测R3 -Chtholly-】T1 浮游大陆的68号岛","slug":"【洛谷10月月赛R2·浴谷八连测R3-Chtholly-】T1-浮游大陆的68号岛","date":"2017-10-20T16:00:00.000Z","updated":"2019-01-04T15:46:07.196Z","comments":true,"path":"2017/10/21/【洛谷10月月赛R2·浴谷八连测R3-Chtholly-】T1-浮游大陆的68号岛/","link":"","permalink":"https://github.tfx2001.pw/2017/10/21/【洛谷10月月赛R2·浴谷八连测R3-Chtholly-】T1-浮游大陆的68号岛/","excerpt":"","text":"【题目链接】 题目大意有$n$个仓库，每个仓库有$x_{i}$个货物，第$i$个仓库与第$i+1$个仓库之间的距离为$d_{i}$。储物点$i$的东西要运到储物点$j$，代价为$x \\times dist\\left( i,j\\right)$，其中$dist\\left( i,j\\right)$为仓库$i$和$j$之间的距离。 分析直接上正解吧，首先求出每个仓库的位置$x_{i}$。对于每次询问，我们分成三种情况，分别为： 目标仓库在区间的左边 $ans=b_{l}\\cdot \\left( x_{l}-x\\right)+b_{l+1}\\cdot \\left( x_{l+1}-x\\right)+…+b_{r}\\cdot \\left( x_{r}-x\\right)$ $ans=\\sum b_{i}x_{i}-x\\sum b_{i}$ 目标仓库在区间的右边 $ans=x\\sum b_{i}-\\sum b_{i}x_{i}$ 目标仓库在区间中间 把区间分成左右两个部分，然后分别计算。 需要预处理三组前缀和，分别为$x_{i},b_{i},b_{i}x_{i}$。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;bits/stdc++.h&gt;using namespace std;const int MOD = 19260817; //十九大还没开完呢，就这么暴力const int MAXN = 200000 + 10;typedef long long LL;LL pos[MAXN], weight[MAXN], pos_2[MAXN]; //pos为bixi，weight为bi，pos_2为xiint n, m;int main(int argc, char const *argv[])&#123; //freopen(\"in.txt\", \"r\", stdin); //freopen(\"out.txt\", \"w\", stdout); ios::sync_with_stdio(false); cin &gt;&gt; n &gt;&gt; m; int d; pos[1] = 1; pos_2[1] = 1; for (int i = 2; i &lt;= n; i++) &#123; cin &gt;&gt; d; //处理前缀和 pos[i] = (pos[i - 1] + d) % MOD; //各种膜，能膜的地方就膜 pos_2[i] = (pos_2[i - 1] + d) % MOD; &#125; int b; for (int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; b; weight[i] = (weight[i - 1] + b) % MOD; pos[i] = ((pos[i] * b) % MOD + pos[i - 1]) % MOD; &#125; int x, l, r; LL ans = 0; for (int i = 0; i &lt; m; i++) &#123; cin &gt;&gt; x &gt;&gt; l &gt;&gt; r; if (x &lt;= l) &#123; ans = ((pos[r] - pos[l - 1]) - (pos_2[x] * (weight[r] - weight[l - 1])) % MOD) % MOD; &#125; else if (x &gt; r) &#123; ans = (pos_2[x] * (weight[r] - weight[l - 1]) % MOD - (pos[r] - pos[l - 1])) % MOD; &#125; else &#123; ans = ((pos_2[x] * (weight[x] - weight[l - 1]) % MOD - (pos[x] - pos[l - 1])) + ((pos[r] - pos[x - 1]) - pos_2[x] * (weight[r] % MOD - weight[x - 1]))) % MOD; &#125; if (ans &lt; 0) //这里注意特判一下，如果ans&lt;0，则需要加上一个长者的生日 cout &lt;&lt; ans + MOD &lt;&lt; endl; else cout &lt;&lt; ans &lt;&lt; endl; &#125; return 0;&#125;","categories":[{"name":"OI","slug":"OI","permalink":"https://github.tfx2001.pw/categories/OI/"}],"tags":[{"name":"Luohu","slug":"Luohu","permalink":"https://github.tfx2001.pw/tags/Luohu/"},{"name":"前缀和","slug":"前缀和","permalink":"https://github.tfx2001.pw/tags/前缀和/"}]},{"title":"【UVa-10129】Play on Words","slug":"【UVa-10129】Play-on-Words","date":"2017-10-08T16:00:00.000Z","updated":"2019-01-04T15:54:30.831Z","comments":true,"path":"2017/10/09/【UVa-10129】Play-on-Words/","link":"","permalink":"https://github.tfx2001.pw/2017/10/09/【UVa-10129】Play-on-Words/","excerpt":"","text":"【题目链接】 题目大意第一行有一个正整数$T$,表示有$T$组测试数据；每组测试数据的第一行有一个正整数$n$，表示有$n$个单词，接下来输入$n$个单词，每个单词最多包含$1000$个小写字母，输入中可以有重复单词。是否可以把这些单词排成一个序列，使得每个单词的第一个字母和上一个单词的最后一个字母相同（例如acm， malform， mouse）。如果可以输出Ordering is possible.，否则输出The door cannot be opened.。 分析先来讲讲有关图论的知识。 在无向图中，能否从图中的一个结点出发走出一条道路，每边恰好经过一次，这样的路线称为欧拉道路（Eulerian path），也可以形象地成为“一笔画”。无向图中存在欧拉路径的条件为：图是连通的，且最多只有两个结点的度为奇数（又称奇点）。如果有两个奇点，则必须从其中的一个奇点出发，另一个奇点终止；如果奇点不存在。则可以从任一点出发，最终回到起点（称为欧拉回路）。有向图中，存在欧拉路的条件为：最多只能有两个点的出度不等于入度，而且必须其中一个点的出度比入度大$1$（作为终点），另一个点的入度比出度大$1$（作为起点）。还有一个前提条件：在忽略边的方向后，图必须是连通的。下面是程序，它同时适用于欧拉道路和回路。如果需要打印欧拉道路，在主程序调用时，参数必须是道路的起点。另外，打印的顺序是逆序的，因此在调用这份代码时，应该把printf语句改成一条push语句，把边$(u,v)$压入一个栈内。 12345678void euler(int u) &#123; for (int v = 0; v &amp;lt; n; v++) if (G[u][v] &amp;amp;&amp;amp; !vis[u][v]) &#123; vis[u][v] = vis[v][u] = 1; euler(v); printf(&amp;quot;%d %d\\n&amp;quot;, u, v); &#125;&#125; 下面进入正题。我们可以把每个单词的首尾两个字母看成结点，用一条边把它们连起来。则问题有解，当且仅当图中有欧拉路径。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &amp;lt;bits/stdc++.h&amp;gt;using namespace std;const int MAXN = 100010;string s;int T, n, degree[30][2];bool G[30][30], vis[30];set&amp;lt;char&amp;gt; char_cnt;int dfs(int u) &#123; //DFS查找结点个数 int ans = 1; vis[u] = true; for (int v = 0; v &amp;lt; 26; v++) &#123; if (!vis[v] &amp;amp;&amp;amp; G[u][v]) ans += dfs(v); &#125; return ans;&#125;int main() &#123; cin &amp;gt;&amp;gt; T; for (int i = 0; i &amp;lt; T; i++) &#123; cin &amp;gt;&amp;gt; n; memset(G, 0, sizeof(G)); memset(vis, 0, sizeof(vis)); memset(degree, 0, sizeof(degree)); char_cnt.clear(); for (int j = 0; j &amp;lt; n; j++) &#123; cin &amp;gt;&amp;gt; s; G[s[0] - &amp;#39;a&amp;#39;][s[s.size() - 1] - &amp;#39;a&amp;#39;] = true; //在判断图的连通性时是无向图，所以要反向存一次边 G[s[s.size() - 1] - &amp;#39;a&amp;#39;][s[0] - &amp;#39;a&amp;#39;] = true; degree[s[0] - &amp;#39;a&amp;#39;][0]++;//入度++ degree[s[s.size() - 1] - &amp;#39;a&amp;#39;][1]++;//出度++ char_cnt.insert(s[0]);//统计有多少个结点，用set char_cnt.insert(s[s.size() - 1]); &#125; bool isDegree = true, isLiantong = true; //isDegree用于标记结点的入度和出度是否符合存在欧拉路的条件 //isLiantong用于标记图是否连通 if (dfs(s[0] - &amp;#39;a&amp;#39;) != char_cnt.size())//通过判断结点个数以判断是否连通 isLiantong = false; int notSame = 0, notSameChar[2];//记录b出度不等于入度的结点的信息 for (int j = 0; j &amp;lt; 26; j++) &#123; if (degree[j][0] != degree[j][1]) &#123; if ((++notSame) &amp;gt; 2) &#123; isDegree = false; break; &#125; notSameChar[notSame - 1] = j; &#125; &#125; if (notSame == 2 &amp;amp;&amp;amp; (abs(degree[notSameChar[0]][0] - degree[notSameChar[0]][1]) != 1 || abs(degree[notSameChar[1]][0] - degree[notSameChar[1]][1]) != 1)) //判断是否只有两个点的出度不等于入度且出度和入度相差1 isDegree = false; if (isDegree &amp;amp;&amp;amp; isLiantong) cout &amp;lt;&amp;lt; &amp;quot;Ordering is possible.&amp;quot; &amp;lt;&amp;lt; endl; else cout &amp;lt;&amp;lt; &amp;quot;The door cannot be opened.&amp;quot; &amp;lt;&amp;lt; endl; &#125; return 0;&#125; 参考文献[1] 刘汝佳. 算法竞赛入门经典.第2版[M]. 清华大学出版社, 2014.","categories":[{"name":"OI","slug":"OI","permalink":"https://github.tfx2001.pw/categories/OI/"}],"tags":[{"name":"UVa","slug":"UVa","permalink":"https://github.tfx2001.pw/tags/UVa/"},{"name":"图论","slug":"图论","permalink":"https://github.tfx2001.pw/tags/图论/"},{"name":"欧拉回路","slug":"欧拉回路","permalink":"https://github.tfx2001.pw/tags/欧拉回路/"}]},{"title":"【UVa-10305】Ordering Tasks","slug":"【UVa-10305】Ordering-Tasks","date":"2017-10-05T16:00:00.000Z","updated":"2019-01-04T15:57:00.593Z","comments":true,"path":"2017/10/06/【UVa-10305】Ordering-Tasks/","link":"","permalink":"https://github.tfx2001.pw/2017/10/06/【UVa-10305】Ordering-Tasks/","excerpt":"","text":"【题目链接】 题目大意给定$1\\leq n\\leq 100$和$m$，表示有$n$个任务，所有任务之间有$m$个关系，接下来$m$行，每行包含两个整数$i$，$j$，表示在进行$j$任务之前必须完成$i$任务。 分析把每个任务看成一个点，“前提任务”看成有向边，则得到了一个有向图，我们把这个有向图叫做AOV网（顶点活动网，Activity On Vertex network）。这样，我们的任务实际上就是把图中的所有节点排序，使得每一条有向边$(u,v)$对应的$u$都排在$v$的前面。在图论中，这个问题成为拓扑排序。 不难发现：如果这个图中存在有向环，则不存在拓扑排序，反之则存在。不包含任何有向环的有向图成为有向无环图（Directed Acyclic Graph, DAG）。可以借助DFS完成拓扑排序：在完成一个结点后把它加在当前拓扑序的首部。 为什么是加到首部呢？因为在DFS的时候，假设当前节点为最后一个，即该结点出度为0，那么就可以把它放到拓扑序的首部（序列中只有这一个结点），然后回溯。在回溯的过程中，依次确定结点。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;bits/stdc++.h&gt;using namespace std;const int MAXN = 110;int c[MAXN], G[MAXN][MAXN];int ans[MAXN];int t, n, m;bool dfs(int u)&#123; c[u] = -1; //-1表示正在访问 for (int v = 1; v &lt;= n; v++) &#123; if (G[u][v]) &#123; if (c[v] == -1) //如果当前节点正在被访问，说明有环 return false; else if (!c[v] &amp;&amp; !dfs(v)) //如果没有被访问过且接下来有环，因为只有出现了环才会return false，这里利用了&amp;&amp;是“短路”运算符的性质 return false; &#125; &#125; c[u] = 1; ans[--t] = u; //把当前结点加在拓扑序的首部 return true;&#125;bool toposort()&#123; t = n; int i; for (i = 1; i &lt;= n; i++) if (!c[i] &amp;&amp; !dfs(i)) return false; return true;&#125;int main()&#123; while (cin &gt;&gt; n &gt;&gt; m &amp;&amp; n + m) &#123; memset(G, false, sizeof(G)); memset(c, 0, sizeof(c)); int i, a, b; for (i = 0; i &lt; m; i++) &#123; cin &gt;&gt; a &gt;&gt; b; G[a][b] = true; &#125; if (toposort()) for (i = 0; i &lt; n - 1; i++) cout &lt;&lt; ans[i] &lt;&lt; ' '; cout &lt;&lt; ans[n - 1] &lt;&lt; endl; &#125; return 0;&#125; 参考文献[1] 刘汝佳. 算法竞赛入门经典.第2版[M]. 清华大学出版社, 2014.","categories":[{"name":"OI","slug":"OI","permalink":"https://github.tfx2001.pw/categories/OI/"}],"tags":[{"name":"UVa","slug":"UVa","permalink":"https://github.tfx2001.pw/tags/UVa/"},{"name":"图论","slug":"图论","permalink":"https://github.tfx2001.pw/tags/图论/"},{"name":"拓扑排序","slug":"拓扑排序","permalink":"https://github.tfx2001.pw/tags/拓扑排序/"}]},{"title":"Hello World","slug":"Hello-World-1","date":"2017-10-04T16:00:00.000Z","updated":"2019-01-04T16:07:18.152Z","comments":true,"path":"2017/10/05/Hello-World-1/","link":"","permalink":"https://github.tfx2001.pw/2017/10/05/Hello-World-1/","excerpt":"","text":"一开始是没想过要做一个Blog的，但是学校的老师让我们开一个Blog，写题解，还要搞一个整合……于是我就想做一个Blog，正好可以写一些文章什么的。 老师推荐用博客园或CSDN， 但觉得界面太恶心，于是就打算自己写框架挂在GitHub Pages上。 之前做过一个网站，本来是打算沿用Bootstrap框架的，但是沉迷Material Design，于是上网找了找，决定使用Materialize框架。然后评论系统还是用之前搭的那个网站的DISQUS，但是需要科学上网…… 既然是Hello World， 那就放一段Hello World的代码吧。 123456#include &lt;bits/stdc++.h&gt;using namespace std; int main() &#123; cout &lt;&lt; \"Hello, World\" &lt;&lt; endl; return 0;&#125; 2017-10-29 Update这次加入了一个博客生成器——Jekyll，每次只需在特定文件夹里写好.md文件，就可以根据模板中的设置，生成对应的静态.html文件，所以只用专注于文章，而不用把注意力放在HTML上，写博客的速度大大加快。","categories":[{"name":"Daily","slug":"Daily","permalink":"https://github.tfx2001.pw/categories/Daily/"}],"tags":[]}]}