<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>在PySide2中使用HTML做UI（一）</title>
      <link href="/2019/01/06/%E5%9C%A8PySide2%E4%B8%AD%E4%BD%BF%E7%94%A8HTML%E5%81%9AUI%EF%BC%88%E4%B8%80%EF%BC%89/"/>
      <url>/2019/01/06/%E5%9C%A8PySide2%E4%B8%AD%E4%BD%BF%E7%94%A8HTML%E5%81%9AUI%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>最近笔者一直在思考一个问题：<strong>如何快速地写出具有好看UI的Qt程序？</strong>经过查阅相关资料发现，大概有两个解决方案：</p><ul><li><code>Qt Quick</code></li><li><code>Qt WebEngine</code>，（类似<code>Electron</code>）</li></ul><a id="more"></a><p>这两个方案该如何选择呢？从性能上考虑，无疑是<code>Qt Quick</code>，但是HTML已经相当成熟，各种前端库层出不穷，开发起来非常方便，作为一个<del>苦逼的</del>个人开发者，我选择HTML。</p><p>目前Qt的官方实现又新加入了Python语言（<code>PySide2</code>，开源协议为<code>LGPL v3</code>非官方的实现是<code>PyQt5</code>，但开源协议为<code>GPL v3</code>），对比C++，Python的优势仍是库多，但运行速度方面远不如C++，不过PySide2的核心代码是用C++实现的，缩小了速度方面的差距。所以做一些小程序的话Python仍是个不错的选择。</p><p>说了那么多，让我们进入正题，先来讲讲PySide2中WebEngine的基本使用方法。</p><p>首先，引入我们需要用到的库，然后创建一个QApplication对象，这是每个Qt应用程序的基础。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> PySide2 <span class="keyword">import</span> QtWidgets, QtCore, QtGui, QtWebEngineWidgets</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">app = QtWidgets.QApplication(sys.argv)</span><br></pre></td></tr></table></figure><p>接着创建一个QWebEngineView，用于显示HTML内容。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">widget = QtWebEngineWigets.QWebEngineView()</span><br></pre></td></tr></table></figure><p>最后使用<code>load()</code>方法打开指定的网页。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">widget.load(<span class="string">'https://github.tfx2001.pw'</span>)</span><br><span class="line"></span><br><span class="line">sys.exit(app.exec_())</span><br></pre></td></tr></table></figure><p>别忘了<code>exec_（）</code>。</p><p>基本用法就是这些了，后面的文章中会提到如何调试网页（开发人员工具）以及如何实现HTML与Python的交互。</p>]]></content>
      
      
      <categories>
          
          <category> Programming </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> PySide2 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2019/01/03/Hello-World-3/"/>
      <url>/2019/01/03/Hello-World-3/</url>
      
        <content type="html"><![CDATA[<p>算是第三次搭博客了……这次重新回到<code>Github Pages</code>，并换上了<code>Hexo</code>。</p><p><del>希望这次不要再弃坑了吧</del></p><p>周末就把之前的文章搬运过来。</p>]]></content>
      
      
      <categories>
          
          <category> Daily </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>消失的水街</title>
      <link href="/2018/04/20/%E6%B6%88%E5%A4%B1%E7%9A%84%E6%B0%B4%E8%A1%97/"/>
      <url>/2018/04/20/%E6%B6%88%E5%A4%B1%E7%9A%84%E6%B0%B4%E8%A1%97/</url>
      
        <content type="html"><![CDATA[<p>之前有人和我说<code>我想吃芝麻糊</code>，脑中便冒出<code>水街</code>——南宁美食最多的地方之一，因为在小学的时候我妈就经常带我去水街吃豆腐花、芝麻糊还有粉饺，于是我就打算在三月三期间去一次水街。</p><p>在去之前听说水街因为旧城改造搬迁了，在网上查了查发现是真的，但是不知道拆成什么样了，在去之后发现情况远比我想象糟糕得多。</p><h1 id="南宁书城"><a href="#南宁书城" class="headerlink" title="南宁书城"></a>南宁书城</h1><p><img src="https://s1.ax1x.com/2018/04/20/CKIMSs.md.jpg" alt="CK2OLF.jpg" title="南宁书城"></p><a id="more"></a><h1 id="新华路水塔"><a href="#新华路水塔" class="headerlink" title="新华路水塔"></a>新华路水塔</h1><p><img src="https://s1.ax1x.com/2018/04/20/CKI8mV.md.jpg" alt="CKRpJ1.jpg" title="新华路水塔"></p><h1 id="如今的水街"><a href="#如今的水街" class="headerlink" title="如今的水街"></a>如今的水街</h1><p><img src="https://s1.ax1x.com/2018/04/20/CKIJTU.md.jpg" alt="CKIJTU.jpg"></p><p><img src="https://s1.ax1x.com/2018/04/20/CKIUfJ.md.jpg" alt="CKIUfJ.jpg"></p><p>图中可以看到明显的<code>拆</code>字，但是就在店铺<code>洋之威劳保</code>的门口旁有三块醒目的文物保护标志（具体见下图）。</p><p><img src="https://s1.ax1x.com/2018/04/20/CKIBOx.md.jpg" alt="CKIBOx.jpg"></p><h1 id="新会书院"><a href="#新会书院" class="headerlink" title="新会书院"></a>新会书院</h1><p><img src="https://s1.ax1x.com/2018/04/20/CKIdp9.md.jpg" alt="CKIdp9.jpg"></p><p>新会书院是南宁市迄今保存最完整，规模最大的清代会馆建筑，已被列为自治区级文物保护单位。</p><p>新会书院曾作为同乡聚会，商会议事的活动场所，日常作为学堂使用，供新会商人的后代上学读书，现已成为国家级非物质文化遗产<code>邕剧</code>的传承基地与展示中心，将邕剧艺术与岭南传统建筑完美地融为一体，是南宁和广西历史文化的一个缩影。</p><p><img src="https://s1.ax1x.com/2018/04/20/CKIo0f.md.jpg" alt="CKIo0f.jpg"></p><p><img src="https://s1.ax1x.com/2018/04/20/CKIgte.md.jpg" alt="CKIgte.jpg"></p><p><img src="https://s1.ax1x.com/2018/04/20/CKIyTO.md.jpg" alt="CKIyTO.jpg"></p><p><img src="https://s1.ax1x.com/2018/04/20/CKIWpd.md.jpg" alt="CKIWpd.jpg"></p><p><img src="https://s1.ax1x.com/2018/04/20/CKIvXq.md.jpg" alt="CKIvXq.jpg"></p><p><img src="https://s1.ax1x.com/2018/04/20/CKIqhQ.md.jpg" alt="CKIqhQ.jpg"></p><p>精美的屋檐。</p><h1 id="水街的美食"><a href="#水街的美食" class="headerlink" title="水街的美食"></a>水街的美食</h1><p>因为水街搬迁，原先的店铺也搬到了附近的一个政府建设的美食城，其实已经两三年了……尽管美食还是原来的美食，但还是觉得有一些遗憾，毕竟那条承载着老南宁记忆的水街已经变成一片废墟了。</p><p><img src="https://s1.ax1x.com/2018/04/20/CKIX1s.md.jpg" alt="CKIX1s.jpg"></p><p><img src="https://s1.ax1x.com/2018/04/20/CKoNHf.md.jpg" alt="CKoNHf.jpg"></p><p>用传统方法现蒸的卷筒粉。</p><p><img src="https://s1.ax1x.com/2018/04/20/CKoaE8.md.jpg" alt="CKoaE8.md.jpg"></p><p>个人认为黄皮酱才是粉饺的精髓（笑。</p><h1 id="At-Last"><a href="#At-Last" class="headerlink" title="At Last"></a>At Last</h1><p>看着水街变成这样，觉得挺遗憾的，在城市发展的过程中，有越来越多像水街一样的地方消失，最终只存在于一张张的老照片里。希望有关部门能更好地将它们保护起来，而不是拆迁！</p><h1 id="压缩图片与打水印"><a href="#压缩图片与打水印" class="headerlink" title="压缩图片与打水印"></a>压缩图片与打水印</h1><p>在写文的过程中用到了大量的图片，每张图片原图基本上都有5~6MB，想到用Python的<code>PIL</code>库来处理，剩下的就交给程序就好啦！</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image, ImageDraw, ImageFont</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 指定要使用的字体和大小；/Library/Fonts/是macOS字体目录；Linux的字体目录是/usr/share/fonts/</span></span><br><span class="line">font = ImageFont.truetype(<span class="string">'Deng.ttf'</span>, <span class="number">36</span>)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># image: 图片   text：要添加的文本  font：字体</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_text_to_image</span><span class="params">(image, text, font=font)</span>:</span></span><br><span class="line">    rgba_image = image.convert(<span class="string">'RGBA'</span>)</span><br><span class="line">    text_overlay = Image.new(<span class="string">'RGBA'</span>, rgba_image.size, (<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>, <span class="number">0</span>))</span><br><span class="line">    image_draw = ImageDraw.Draw(text_overlay)</span><br><span class="line"> </span><br><span class="line">    text_size_x, text_size_y = image_draw.textsize(text, font=font)</span><br><span class="line">    <span class="comment"># 设置文本文字位置</span></span><br><span class="line">    print(rgba_image)</span><br><span class="line">    text_xy = (rgba_image.size[<span class="number">0</span>] - text_size_x - <span class="number">30</span>, rgba_image.size[<span class="number">1</span>] - text_size_y - <span class="number">15</span>)</span><br><span class="line">    <span class="comment"># 设置文本颜色和透明度</span></span><br><span class="line">    image_draw.text(text_xy, text, font=font, fill=(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">70</span>))</span><br><span class="line"> </span><br><span class="line">    image_with_text = Image.alpha_composite(rgba_image, text_overlay)</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> image_with_text</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> fn <span class="keyword">in</span> os.listdir():</span><br><span class="line">    <span class="comment">#print(fn.split('.')[1])</span></span><br><span class="line">    <span class="keyword">if</span> <span class="string">'JPG'</span> <span class="keyword">in</span> fn:</span><br><span class="line">        im_before = Image.open(fn)</span><br><span class="line">        <span class="comment"># 缩放图片</span></span><br><span class="line">        im_before.thumbnail((im_before.size[<span class="number">0</span>] / <span class="number">3</span>, im_before.size[<span class="number">1</span>] / <span class="number">3</span>))</span><br><span class="line">        im_after = add_text_to_image(im_before, <span class="string">'Taken by tfx2001.'</span>)</span><br><span class="line">        im_after = im_after.convert(<span class="string">'RGB'</span>)</span><br><span class="line">        im_after.save(fn, <span class="string">'JPEG'</span>)</span><br><span class="line">        print(im_after)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Photography </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2018/04/15/Hello-World-2/"/>
      <url>/2018/04/15/Hello-World-2/</url>
      
        <content type="html"><![CDATA[<p>第二次搭博客，这次比上次更新了不少，也花了挺多时间的，但还是有收获吧。</p><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>这次博客前端框架采用了<code>MDUI</code>（毕竟重度Material Design中毒患者），后端是用<code>Flask</code>框架，<code>nginx</code>为Web服务器，<code>uWSGI</code>作为中间件。</p><a id="more"></a><h1 id="What’s-new"><a href="#What’s-new" class="headerlink" title="What’s new?"></a>What’s new?</h1><p>这次更新坠重要的就是可以直接在web上写文章，由后端进行Markdown与HTML的转换，再也不需要用Gayhub Page啦！</p><h1 id="本Blog的诞生离不开以下优秀的开源项目"><a href="#本Blog的诞生离不开以下优秀的开源项目" class="headerlink" title="本Blog的诞生离不开以下优秀的开源项目"></a>本Blog的诞生离不开以下优秀的开源项目</h1><ul><li><a href="https://github.com/highlightjs/cdn-release" target="_blank" rel="noopener">highlight.js</a></li><li><a href="https://mdui.org" target="_blank" rel="noopener">MDUI</a></li><li><a href="https://jquery.com" target="_blank" rel="noopener">jQuery</a></li><li><a href="https://github.com/pallets/flask" target="_blank" rel="noopener">Flask</a></li><li><a href="https://github.com/trentm/python-markdown2" target="_blank" rel="noopener">markdown2</a></li><li><a href="https://github.com/Khan/KaTeX" target="_blank" rel="noopener">$KaTeX$</a></li><li><a href="https://github.com/luogu-dev/markdown-palettes" target="_blank" rel="noopener">markdown-palettes</a></li></ul><h1 id="评论系统">评论系统</h1><p>最终还是决定用<code>Disqus</code>，尽管要搭梯子，因为相比起多说<del>（已经凉凉）</del>、畅言，它的后台管理和UI真的很棒。</p><p><strong>欢迎各位dalao搭梯子来评论！</strong></p>]]></content>
      
      
      <categories>
          
          <category> Daily </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>【模板】读入输出优化</title>
      <link href="/2017/11/08/%E3%80%90%E6%A8%A1%E6%9D%BF%E3%80%91%E8%AF%BB%E5%85%A5%E8%BE%93%E5%87%BA%E4%BC%98%E5%8C%96/"/>
      <url>/2017/11/08/%E3%80%90%E6%A8%A1%E6%9D%BF%E3%80%91%E8%AF%BB%E5%85%A5%E8%BE%93%E5%87%BA%E4%BC%98%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<p>在准备复赛的时候，我们的老师说：</p><blockquote><p>你们写读入输出优化的时候，不要乱用网上的那些模板啊，如果爆零就……</p></blockquote><p>所以，给一个正确的读入输出优化的模板吧。</p><a id="more"></a><h3 id="读入"><a href="#读入" class="headerlink" title="读入"></a>读入</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>, flag = <span class="number">0</span>; <span class="comment">//flag用于判负数</span></span><br><span class="line"><span class="keyword">char</span> ch = getchar();</span><br><span class="line"><span class="keyword">while</span> ((ch &lt; <span class="string">'0'</span> || ch &gt; <span class="string">'9'</span>) &amp;&amp; ch != <span class="string">'-'</span>)</span><br><span class="line">ch = getchar();</span><br><span class="line"><span class="keyword">if</span> (ch == <span class="string">'-'</span>) &#123;</span><br><span class="line">flag = <span class="number">1</span>;</span><br><span class="line">ch = getchar();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (ch &gt;= <span class="string">'0'</span> &amp;&amp; ch &lt;= <span class="string">'9'</span>) &#123;</span><br><span class="line">ans = ans * <span class="number">10</span> + ch - <span class="string">'0'</span>;</span><br><span class="line">ch = getchar();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (flag)</span><br><span class="line">ans = -ans;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (i &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">putchar</span>(<span class="string">'-'</span>);</span><br><span class="line">i = -i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (i &gt;= <span class="number">10</span>)</span><br><span class="line">put(i / <span class="number">10</span>);</span><br><span class="line"><span class="built_in">putchar</span>(i % <span class="number">10</span> + <span class="string">'0'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 模板 </tag>
            
            <tag> 读入输出优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【P1226】取余运算||快速幂</title>
      <link href="/2017/11/05/%E3%80%90P1226%E3%80%91%E5%8F%96%E4%BD%99%E8%BF%90%E7%AE%97-%E5%BF%AB%E9%80%9F%E5%B9%82/"/>
      <url>/2017/11/05/%E3%80%90P1226%E3%80%91%E5%8F%96%E4%BD%99%E8%BF%90%E7%AE%97-%E5%BF%AB%E9%80%9F%E5%B9%82/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.luogu.org/problemnew/show/1226" target="_blank" rel="noopener">【题目链接】</a></p><h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p>输出$\large b^p \space mod \space k$的值。</p><a id="more"></a><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>直接朴素算法，边乘边取余，时间复杂度为$O(n)$，数据一大就会TLE……</p><p>我们可以采用<strong>倍增</strong>的思想，对$b$进行二进制分解，如果前面听不懂也没关系，下面结合具体数字进行讲解。</p><p>例如，$3^{11}=177147$，如果我们用朴素算法的话需要做$10$次乘法。<br>$11$的二进制表示为$1011_{(2)}$，所以\[\large 3^{11}=3^{2^3+2^1+2^0}=3^{2^{3}} \times 3^{2^{1}} \times 3^{2^{0}}\]最终我们只需要做$3$次乘法，时间复杂度降为$O(log \space n)$。</p><p>代码如下。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> b, p, k;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">poww</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> mod)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">1</span>, base = a;</span><br><span class="line">    <span class="keyword">while</span> (b) &#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>)</span><br><span class="line">            ans = (ans * base) % mod;</span><br><span class="line">        base *= base; <span class="comment">//base一开始是a，那么接下来会变成a^(2^1)，a^(2^2)，a^(2^3)……</span></span><br><span class="line">        base %= mod;</span><br><span class="line">        b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; b &gt;&gt; p &gt;&gt; k;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d^%d mod %d=%d\n"</span>, b, p, k, poww(b, p, k));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Luogu </tag>
            
            <tag> 快速幂 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【UVa-11354】Bond</title>
      <link href="/2017/11/01/%E3%80%90UVa-11354%E3%80%91Bond/"/>
      <url>/2017/11/01/%E3%80%90UVa-11354%E3%80%91Bond/</url>
      
        <content type="html"><![CDATA[<p><a href="https://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;page=show_problem&amp;problem=2339" target="_blank" rel="noopener">【题目链接】</a></p><p>十一月的第一篇post，本来昨天已经看完倍增了，但后面又去做了一些题巩固一下，今天写一篇post理一下思路。</p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>有$n$座城市通过$m$条<strong>双向道路</strong>相连，每一条道路都有一个危险系数。你的任务是回答若干个询问。每个询问包含一个起点$s$和一个终点$t$，要求找一条从$s$到$t$的路，使得途径的所有道路的最大危险系数最小。</p><a id="more"></a><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>既然要危险系数最小（先不考虑最大），我们可以先对这个图进行预处理，求出这个图的最小生成树。因为树上两点之间的路径是唯一的，且这条路径肯定会经过这两个点的<strong>最近公共祖先</strong>，<strong>LCA（<b>L</b>east <b>C</b>ommon <b>A</b>ncestor）</strong>，找到这条路径之后就可以统计这条路径上危险系数最大的道路了。那么，怎么求LCA呢？</p><p><b>我们可以打暴力！</b>采用暴力爬链的方式，先要确保两点处于同一深度（如果不在同一深度就把比较深的那个点“提”上来），然后两个点同时一层一层地往上爬，直到两个点相遇，相遇的那个点就是两个点的LCA。这种方法虽然简单，容易理解，但是时间复杂度为$O(n)$……数据一大就很容易超时.</p><p><b>我们可以想优化！</b>这里可以用一种叫做<strong>倍增</strong>的思想来加速。</p><p><strong>倍增</strong>，顾名思义，就是成倍地增长，也就是一次爬多层，这样就可以大大加快爬链的速度。实现的方法与<strong>快速幂</strong>类似，也是用到了二进制展开的方法，时间复杂度变为$O(log \space n)$。</p><p>在求完最小生成树之后，把它转变为<strong>有根树</strong>（具体细节参见代码），然后进行预处理，处理出$anc$数组和$maxCost$数组，其中，$anc(i,j)$表示的是编号$i$的点向上爬$2^j$层的祖先。$maxCost(i,j)$表示的是$i$号点向上爬$2^j$层的路径中危险系数最大的道路的危险系数。代码如下。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> father, <span class="keyword">int</span> level)</span> </span>&#123;<span class="comment">//无根树转有根树</span></span><br><span class="line">dep[u] = level;</span><br><span class="line"><span class="keyword">int</span> size = G[u].size();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> v = G[u][i].v;</span><br><span class="line"><span class="keyword">if</span> (v != father) &#123;<span class="comment">//关键</span></span><br><span class="line">fa[v] = u;<span class="comment">//节点v的父亲</span></span><br><span class="line">cost[v] = G[u][i].w;</span><br><span class="line">dfs(v, u, level + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">preProcess</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">anc[i][<span class="number">0</span>] = fa[i];</span><br><span class="line">maxCost[i][<span class="number">0</span>] = cost[i];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; (<span class="number">1</span> &lt;&lt; j) &lt;= n; j++)</span><br><span class="line">anc[i][j] = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; (<span class="number">1</span> &lt;&lt; j) &lt;= n; j++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line"><span class="keyword">if</span> (anc[i][j - <span class="number">1</span>] != <span class="number">-1</span>) &#123;</span><br><span class="line"><span class="keyword">int</span> a = anc[i][j - <span class="number">1</span>];</span><br><span class="line">anc[i][j] = anc[a][j - <span class="number">1</span>];</span><br><span class="line">maxCost[i][j] = max(maxCost[i][j - <span class="number">1</span>], maxCost[a][j - <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在预处理完毕之后就可以查询了，代码如下。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> <span class="built_in">log</span>;</span><br><span class="line"><span class="keyword">if</span> (dep[p] &lt; dep[q]) <span class="comment">//确保p比q深</span></span><br><span class="line">swap(p, q);</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">log</span> = <span class="number">1</span>; (<span class="number">1</span> &lt;&lt; <span class="built_in">log</span>) &lt;= dep[p]; <span class="built_in">log</span>++);</span><br><span class="line"><span class="built_in">log</span>--;</span><br><span class="line"><span class="keyword">int</span> ans = -(<span class="number">1</span> &lt;&lt; <span class="number">20</span>); <span class="comment">//-INF</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="built_in">log</span>; i &gt;= <span class="number">0</span>; i--) <span class="comment">//把p往上提</span></span><br><span class="line"><span class="keyword">if</span> (dep[p] - (<span class="number">1</span> &lt;&lt; i) &gt;= dep[q]) &#123;</span><br><span class="line">ans = max(ans, maxCost[p][i]);</span><br><span class="line">p = anc[p][i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (p == q) <span class="comment">//LCA为p或q</span></span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="built_in">log</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line"><span class="keyword">if</span> (anc[p][i] != <span class="number">-1</span> &amp;&amp; anc[p][i] != anc[q][i]) &#123;</span><br><span class="line">ans = max(ans, maxCost[p][i]);</span><br><span class="line">p = anc[p][i];</span><br><span class="line">ans = max(ans, maxCost[q][i]);</span><br><span class="line">q = anc[q][i];</span><br><span class="line">&#125;</span><br><span class="line">ans = max(ans, cost[q]);</span><br><span class="line">ans = max(ans, cost[p]);</span><br><span class="line"><span class="keyword">return</span> ans; <span class="comment">//LCA为fa[p]或LCA[q]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>完整代码。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">50010</span>, MAXM = <span class="number">100010</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> u, v, w;</span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Edge&amp; b) <span class="keyword">const</span> &#123;</span><br><span class="line"><span class="keyword">return</span> w &lt; b.w;</span><br><span class="line">&#125;</span><br><span class="line">Edge (<span class="keyword">int</span> u = <span class="number">0</span>, <span class="keyword">int</span> v = <span class="number">0</span>, <span class="keyword">int</span> w = <span class="number">0</span>) : u(u), v(v), w(w)&#123;&#125;</span><br><span class="line">&#125;edge[MAXM];</span><br><span class="line"><span class="keyword">int</span> n, m, fa[MAXN], anc[MAXN][<span class="number">20</span>], dep[MAXN], pa[MAXN], cost[MAXN], maxCost[MAXN][<span class="number">20</span>], kase;</span><br><span class="line"><span class="built_in">vector</span>&lt;Edge&gt; G[MAXN];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getf</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> pa[i] == i ? i : pa[i] = getf(pa[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> father, <span class="keyword">int</span> level)</span> </span>&#123;</span><br><span class="line">dep[u] = level;</span><br><span class="line"><span class="keyword">int</span> size = G[u].size();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> v = G[u][i].v;</span><br><span class="line"><span class="keyword">if</span> (v != father) &#123;</span><br><span class="line">fa[v] = u;</span><br><span class="line">cost[v] = G[u][i].w;</span><br><span class="line">dfs(v, u, level + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">preProcess</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">anc[i][<span class="number">0</span>] = fa[i];</span><br><span class="line">maxCost[i][<span class="number">0</span>] = cost[i];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; (<span class="number">1</span> &lt;&lt; j) &lt;= n; j++)</span><br><span class="line">anc[i][j] = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; (<span class="number">1</span> &lt;&lt; j) &lt;= n; j++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line"><span class="keyword">if</span> (anc[i][j - <span class="number">1</span>] != <span class="number">-1</span>) &#123;</span><br><span class="line"><span class="keyword">int</span> a = anc[i][j - <span class="number">1</span>];</span><br><span class="line">anc[i][j] = anc[a][j - <span class="number">1</span>];</span><br><span class="line">maxCost[i][j] = max(maxCost[i][j - <span class="number">1</span>], maxCost[a][j - <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> <span class="built_in">log</span>;</span><br><span class="line"><span class="keyword">if</span> (dep[p] &lt; dep[q]) <span class="comment">//确保p比q深</span></span><br><span class="line">swap(p, q);</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">log</span> = <span class="number">1</span>; (<span class="number">1</span> &lt;&lt; <span class="built_in">log</span>) &lt;= dep[p]; <span class="built_in">log</span>++);</span><br><span class="line"><span class="built_in">log</span>--;</span><br><span class="line"><span class="keyword">int</span> ans = -(<span class="number">1</span> &lt;&lt; <span class="number">20</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="built_in">log</span>; i &gt;= <span class="number">0</span>; i--) <span class="comment">//把p往上提</span></span><br><span class="line"><span class="keyword">if</span> (dep[p] - (<span class="number">1</span> &lt;&lt; i) &gt;= dep[q]) &#123;</span><br><span class="line">ans = max(ans, maxCost[p][i]);</span><br><span class="line">p = anc[p][i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (p == q)</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="built_in">log</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line"><span class="keyword">if</span> (anc[p][i] != <span class="number">-1</span> &amp;&amp; anc[p][i] != anc[q][i]) &#123;</span><br><span class="line">ans = max(ans, maxCost[p][i]);</span><br><span class="line">p = anc[p][i];</span><br><span class="line">ans = max(ans, maxCost[q][i]);</span><br><span class="line">q = anc[q][i];</span><br><span class="line">&#125;</span><br><span class="line">ans = max(ans, cost[q]);</span><br><span class="line">ans = max(ans, cost[p]);</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span>* argv[])</span> </span>&#123;</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m) &#123;</span><br><span class="line"><span class="keyword">if</span> (kase++)</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">memset</span>(edge, <span class="number">0</span>, <span class="keyword">sizeof</span>(edge));</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">pa[i] = i;</span><br><span class="line">G[i].clear();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; edge[i].u &gt;&gt; edge[i].v &gt;&gt; edge[i].w;</span><br><span class="line"><span class="comment">//最小生成树</span></span><br><span class="line">sort(edge, edge + m);</span><br><span class="line"><span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">Edge&amp; e = edge[i];</span><br><span class="line"><span class="keyword">if</span> (getf(e.u) != getf(e.v)) &#123;</span><br><span class="line">pa[getf(e.v)] = getf(e.u);</span><br><span class="line">cnt++;</span><br><span class="line">G[e.u].push_back(Edge(e.u, e.v, e.w));</span><br><span class="line">G[e.v].push_back(Edge(e.v, e.u, e.w));</span><br><span class="line"><span class="keyword">if</span> (cnt == n - <span class="number">1</span>)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//无根树转有根树</span></span><br><span class="line">dfs(<span class="number">1</span>, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">preProcess();</span><br><span class="line"><span class="keyword">int</span> q;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; q;</span><br><span class="line"><span class="keyword">int</span> u, v;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; q; i++) &#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; u &gt;&gt; v;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; query(u, v) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><p>[1] 刘汝佳. 算法竞赛入门经典.第2版[M]. 清华大学出版社, 2014.</p>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> UVa </tag>
            
            <tag> 倍增 </tag>
            
            <tag> 最近公共祖先，LCA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【NOIp2014】联合权值</title>
      <link href="/2017/10/30/%E3%80%90NOIp2014%E3%80%91%E8%81%94%E5%90%88%E6%9D%83%E5%80%BC/"/>
      <url>/2017/10/30/%E3%80%90NOIp2014%E3%80%91%E8%81%94%E5%90%88%E6%9D%83%E5%80%BC/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.luogu.org/problemnew/show/1351" target="_blank" rel="noopener">【题目链接】</a></p><p>睡觉前再写一篇文章。</p><h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p>无向连通图$G$有$n$个点，$n - 1$条边。点从$1$到$n$依次编号，编号为$i$的点的权值为$w_i$，每条边的长度均为$1$。图上两点$(u,\space v)$的距离定义为$u$点到$v$点的最短距离。对于图$G$上的点对$(u,\space v)$，若它们的距离为$2$，则它们之间会产生$w_u \times w_v$的联合权值。</p><p>请问图$G$上所有可产生联合权值的<strong>有序点对</strong>中，联合权值最大的是多少？所有联合权值之和是多少？</p><a id="more"></a><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p><del><b>我们可以有梦想！</b></del>别想了，这题并没有梦想分。</p><p><b>我们可以打暴力！</b>题目中提到这个图有$n-1$条边，说明这是一棵<strong>无根树</strong> ！只要两个点连接到相同的点就可以产生联合权值。直接在邻接表中暴力枚举每两个点组成的<strong>有序点对</strong>，累加一下，同时更新最大值。时间复杂度$O(VE)$，期望得分60pts（然而我得了70pts是怎么回事……）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">200000</span> + <span class="number">5</span>, MOD = <span class="number">10007</span>;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> n, weight[MAXN];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> ans, max_ans;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; G[MAXN]; <span class="comment">//邻接表存图</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span>* argv[])</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">int</span> u, v;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; u &gt;&gt; v;</span><br><span class="line">        G[u].push_back(v);</span><br><span class="line">        G[v].push_back(u); <span class="comment">//无向图，加两次边</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; weight[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> size = G[i].size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; size; j++) &#123;</span><br><span class="line">            <span class="keyword">int</span> v1 = G[i][j];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; size; k++) &#123;</span><br><span class="line">                <span class="keyword">int</span> v2 = G[i][k];</span><br><span class="line">                <span class="keyword">if</span> (v1 != v2) &#123;</span><br><span class="line">                    ans = (ans + weight[v1] * weight[v2]) % MOD;</span><br><span class="line">                    max_ans = max(max_ans, weight[v1] * weight[v2]); <span class="comment">//更新最大值，不能膜！</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; max_ans &lt;&lt; <span class="string">' '</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><b>我们可以想优化！</b>通过观察可以发现，每个邻接表中的某个点$G(i,j)$可以产生的联合权值为：\[w(i,j) \times w(i,1) + w(i,j) \times w(i,2) + … + w(i,j) \times w(i,k)\]<br>其中$k$为当前邻接表中点的个数且$k \neq j$（因为不能自己乘自己）。我们把上面的公式整理一下，变成：\[w(i,j) \times (w(i,1) + w(i,2) + … + w(i,3))\]<br>所以我们可以预处理每个邻接表$G_{i}$中所有点的权值和$\sum_{j=1}^{k}w(i,j)$，因为$k \neq i$，所以在计算的时候公式如下：\[w(i,j) \times (\sum_{j=1}^{k}w(i,j)-w(i,j))\]<br>至于最大最小值，在遍历的过程中不断比较就行。具体细节参见代码。</p><p>这个算法的时间复杂度为$O(n)$，期望得分100分。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">200000</span> + <span class="number">5</span>, MOD = <span class="number">10007</span>;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> n, weight[MAXN], sum[MAXN];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> ans, max_ans;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; G[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span>* argv[])</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">int</span> u, v;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; u &gt;&gt; v;</span><br><span class="line">        G[u].push_back(v);</span><br><span class="line">        G[v].push_back(u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; weight[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> size = G[i].size();</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> max1 = <span class="number">0</span>, max2 = <span class="number">0</span>; <span class="comment">//最大值和次大值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; size; j++) &#123;</span><br><span class="line">            <span class="keyword">int</span> v = G[i][j];</span><br><span class="line">            sum[i] += weight[v]; <span class="comment">//更新当前邻接表中所有点的权值的总和</span></span><br><span class="line">            <span class="keyword">if</span> (weight[v] &gt; max1) &#123; <span class="comment">//更新最大值</span></span><br><span class="line">                max2 = max1;</span><br><span class="line">                max1 = weight[v];</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (weight[v] &gt; max2)</span><br><span class="line">                max2 = weight[v];</span><br><span class="line">        &#125;</span><br><span class="line">        max_ans = max(max_ans, max1 * max2);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> size = G[i].size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; size; j++) &#123;</span><br><span class="line">            ans = (ans + weight[G[i][j]] * (sum[i] - weight[G[i][j]])) % MOD; <span class="comment">//这里别忘了膜</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; max_ans &lt;&lt; <span class="string">' '</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NOIp2014 </tag>
            
            <tag> 动态规划，动规，dp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【P1120】小木棍［数据加强版］</title>
      <link href="/2017/10/30/%E3%80%90P1120%E3%80%91%E5%B0%8F%E6%9C%A8%E6%A3%8D%EF%BC%BB%E6%95%B0%E6%8D%AE%E5%8A%A0%E5%BC%BA%E7%89%88%EF%BC%BD/"/>
      <url>/2017/10/30/%E3%80%90P1120%E3%80%91%E5%B0%8F%E6%9C%A8%E6%A3%8D%EF%BC%BB%E6%95%B0%E6%8D%AE%E5%8A%A0%E5%BC%BA%E7%89%88%EF%BC%BD/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.luogu.org/problemnew/show/P1120" target="_blank" rel="noopener">【题目链接】</a></p><h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p>乔治一开始有一堆<strong>同样长</strong>的小木棍，然后他把这些木棍随意砍成几段，直到每段的长都不超过50。</p><p>现在，他想把小木棍拼接成原来的样子，但是却忘记了自己开始时有多少根木棍和它们的长度。</p><p>输出原始木棍的最小可能长度。</p><a id="more"></a><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>这是一道搜索题，但是数据范围有点大，需要剪枝，本蒟蒻用到的剪枝如下：</p><ol><li><p>先去掉所有长度$&gt;50$的木棍，然后<strong>降序排序</strong>，这是为了实现后面的剪枝。</p></li><li><p>计所有木棍的总长度为$sum$，当前木棍中最长的木棍长度为$a_0$（请参考程序）。</p><p>枚举范围为$[a_0,\space sum]$，计当前枚举到的长度为$len_i$，当且仅当$len_i$为$sum$的因数时开始dfs。</p></li><li><p>如果$l==t-1$（$l$为当前搜到的第几组木棍），则说明搜到解。</p></li><li><p>$vis$数组，不用解释了吧？</p></li><li><p>如果当前的木棍长度与$s$的和大于$len_i$，则continue。</p></li><li><p>如果前面同样长度的木棍不合法，那么这当前长度的木棍也肯定不合法。</p></li><li><p>如果$s==0​$（$s​$为当前组的木棍总长度）且无解，说明后面的木棍不合法，直接返回。</p></li><li><p>如果$s+a_i==len_i$，说明能组成一组木棍但是无解，说明继续往下搜索已经不可能找到解，返回。</p></li></ol><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">70</span>;</span><br><span class="line"><span class="keyword">int</span> n, a[MAXN], sum, m, t, cnt;</span><br><span class="line"><span class="keyword">bool</span> vis[MAXN];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> s, <span class="keyword">int</span> p)</span> </span>&#123; <span class="comment">//p用于减少循环次数</span></span><br><span class="line"><span class="keyword">if</span> (s == m) &#123;</span><br><span class="line">s = <span class="number">0</span>;</span><br><span class="line">l++;</span><br><span class="line">p = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (l == t - <span class="number">1</span>) &#123; <span class="comment">//剪枝3</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = p + <span class="number">1</span>; i &lt; cnt; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (s + a[i] &gt; m || vis[i]) <span class="comment">//剪枝4和5</span></span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">if</span> (a[i] == a[i - <span class="number">1</span>] &amp;&amp; (!vis[i - <span class="number">1</span>])) <span class="comment">//剪枝6</span></span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">vis[i] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (dfs(l, s + a[i], i))</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">vis[i] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (!s) <span class="comment">//剪枝7</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">if</span> (s + a[i] == m) <span class="comment">//剪枝8</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span>* argv[])</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">cnt = n;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line"><span class="keyword">if</span> (a[i] &gt; <span class="number">50</span>) &#123; <span class="comment">//去掉长度大于50的木棍</span></span><br><span class="line">a[i] = <span class="number">0</span>;</span><br><span class="line">cnt--;</span><br><span class="line">&#125;</span><br><span class="line">sum += a[i];</span><br><span class="line">&#125;</span><br><span class="line">sort(a, a + n, greater&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = a[<span class="number">0</span>]; i &lt;= sum; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (!(sum % i)) &#123;<span class="comment">//剪枝2</span></span><br><span class="line">m = i;</span><br><span class="line">t = sum / i;</span><br><span class="line"><span class="keyword">if</span> (dfs(<span class="number">0</span>, <span class="number">0</span>, <span class="number">-1</span>)) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Luogu </tag>
            
            <tag> 枚举 </tag>
            
            <tag> 搜索 </tag>
            
            <tag> 剪枝 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【NOIp2016】玩具迷题</title>
      <link href="/2017/10/25/%E3%80%90NOIp2016%E3%80%91%E7%8E%A9%E5%85%B7%E8%BF%B7%E9%A2%98/"/>
      <url>/2017/10/25/%E3%80%90NOIp2016%E3%80%91%E7%8E%A9%E5%85%B7%E8%BF%B7%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.luogu.org/problemnew/show/1563" target="_blank" rel="noopener">【题目链接】</a></p><h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p>一群小人围成一圈，你需要按照<strong>逆时针</strong>或<strong>顺时针</strong>的方向按顺序数小人，输出最后数到的小人。</p><a id="more"></a><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>一道很水的模拟题……</p><p><b>80pts做法</b>：链表暴力，一步一步模拟，会<b>超时</b>……</p><p><b>正解</b>：一次走多步，具体细节参见代码。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Toy</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> cx;<span class="comment">//朝向</span></span><br><span class="line">    <span class="built_in">string</span> name; <span class="comment">//名字</span></span><br><span class="line">&#125;toy[<span class="number">100010</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Cmd</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> lr;</span><br><span class="line">    <span class="keyword">int</span> num;</span><br><span class="line">&#125;cmd[<span class="number">100010</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,m;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;toy[i].cx&gt;&gt;toy[i].name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;(cmd[i].lr),&amp;(cmd[i].num));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> p=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(toy[p].cx==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(cmd[i].lr==<span class="number">0</span>)&#123;</span><br><span class="line">                p-=cmd[i].num;</span><br><span class="line">                <span class="keyword">if</span>(p&lt;<span class="number">1</span>)<span class="comment">//如果转出圈了，要加上一个n</span></span><br><span class="line">                    p=n+p;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                p+=cmd[i].num;</span><br><span class="line">                <span class="keyword">if</span>(p&gt;n)<span class="comment">//转出圈</span></span><br><span class="line">                    p-=n;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(cmd[i].lr==<span class="number">1</span>)&#123;<span class="comment">//另一个朝向</span></span><br><span class="line">                p-=cmd[i].num;</span><br><span class="line">                <span class="keyword">if</span>(p&lt;<span class="number">1</span>)</span><br><span class="line">                    p=n+p;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                p+=cmd[i].num;</span><br><span class="line">                <span class="keyword">if</span>(p&gt;n)</span><br><span class="line">                    p-=n;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;toy[p].name;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NOIp2016 </tag>
            
            <tag> 模拟 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【NOIp2016】蚯蚓</title>
      <link href="/2017/10/25/%E3%80%90NOIp2016%E3%80%91%E8%9A%AF%E8%9A%93/"/>
      <url>/2017/10/25/%E3%80%90NOIp2016%E3%80%91%E8%9A%AF%E8%9A%93/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.luogu.org/problemnew/show/2827" target="_blank" rel="noopener">【题目链接】</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>有一群蚯蚓，每一秒，你需要找出最长的那一条并且把它切成两半，并根据参数$t$输出第$t$秒，第$2t$秒，第$3t$秒……被切断蚯蚓（在被切断前）的长度，和$m$秒后蚯蚓的长度；需要按从大到小的顺序，依次输出排名第$t$，第$2t$，第$3t$……的长度。</p><a id="more"></a><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p><b>20pts做法：</b>纯模拟……用$O(n)$的时间扫描一遍取出最大值，切成两半，然后全部蚯蚓（除了取出来的）增加长度$q$，最后再把切成的两条蚯蚓放回数组里（当时在赛场上我用的是<code>vector</code>）。最后输出的时候排个序。</p><p><b>80pts做法：</b>既然需要频繁地取出最大值，我们很容易想到（如果这个词伤害了您，我表示深深的歉意）用堆，在这里我用了<code>priority_queue</code>（好像手写堆能得90pts？）。每次取出一条长度最长的蚯蚓，直接pop即可，切成两半后再放回堆里面；输出时就是不断的pop和判断要不要输出。但是还有一个问题：每秒所有蚯蚓<b>（除了被取出的）</b>都要增加长度$q$，如果我们把堆中的元素全部取出来加上长度$q$再放回去，会超时，甚至不如不用堆。既然不能加，那就对于被切成两半的蚯蚓，我们可以减去长度$q$，然后放回堆里。需要注意的是：取出长度一条最长的蚯蚓，<b>这条蚯蚓之前被切过（减去长度$q$）</b>，直接对它进行切半是不正确的，因为向下取整时（$\lfloor c \rfloor$）会有精度的损失，所以我们需要重新给它加上长度$(t - 1)  \times q$（$t$为当前的时间），最后放回堆时记得减去$(t - 1)  \times q$。具体细节参见代码。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">100010</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, q, u, v, t, a[MAXN];</span><br><span class="line"><span class="keyword">double</span> p;</span><br><span class="line">priority_queue&lt;<span class="keyword">int</span>&gt; H;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m &gt;&gt; q &gt;&gt; u &gt;&gt; v &gt;&gt; t;</span><br><span class="line">    p = (<span class="keyword">double</span>)u / v; <span class="comment">//强制类型转换，不然p会是0</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">        H.push(a[i]);<span class="comment">//入堆</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> len = H.top() + (i - <span class="number">1</span>) * q; <span class="comment">//防止精度误差</span></span><br><span class="line">        H.pop();</span><br><span class="line">        <span class="keyword">if</span> (!(i % t))<span class="comment">//判断要不要输出</span></span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; len &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">        <span class="keyword">int</span> len1 = <span class="built_in">floor</span>(len * p) - (i - <span class="number">1</span>) * q;</span><br><span class="line">        <span class="keyword">int</span> len2 = len - <span class="built_in">floor</span>(len * p) - (i - <span class="number">1</span>) * q;</span><br><span class="line">        H.push(len1 - q);</span><br><span class="line">        H.push(len2 - q);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (!H.empty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> ans = H.top();</span><br><span class="line">        H.pop();</span><br><span class="line">        <span class="keyword">if</span> (!(i % t))</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; ans + q * m &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><b>满分做法：</b>用三个<code>单调队列</code>，分别用来存放<b>没有被切的蚯蚓</b>，<b>切成两半的蚯蚓中长的那一条</b>，<b>切成两半的蚯蚓中短的那一条</b>。为什么要用三个队列来存呢？这是为了保证从三个队列的队首中取出一条最长的蚯蚓一定是所有蚯蚓中最长的，做法和堆差不多。具体细节参见代码。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">100010</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, q, u, v, t, a[MAXN];</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; Q, maxQ, minQ;</span><br><span class="line"><span class="keyword">double</span> p;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getMax</span><span class="params">()</span> </span>&#123; <span class="comment">//从三个队列中取出一个最大的数，如果没有数就返回INF</span></span><br><span class="line">    <span class="keyword">int</span> ans = -(<span class="number">1</span> &lt;&lt; <span class="number">30</span>), flag = <span class="number">0</span>;;</span><br><span class="line">    <span class="keyword">if</span> (ans &lt; Q.front() &amp;&amp; Q.size()) &#123;</span><br><span class="line">        ans = Q.front();</span><br><span class="line">        flag = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (ans &lt; maxQ.front() &amp;&amp; maxQ.size()) &#123;</span><br><span class="line">        ans = maxQ.front();</span><br><span class="line">        flag = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (ans &lt; minQ.front() &amp;&amp; minQ.size()) &#123;</span><br><span class="line">        ans = minQ.front();</span><br><span class="line">        flag = <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">switch</span>(flag) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            Q.pop();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            maxQ.pop();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">            minQ.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (flag == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span>* argv[])</span> </span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m &gt;&gt; q &gt;&gt; u &gt;&gt; v &gt;&gt; t;</span><br><span class="line">    p = (<span class="keyword">double</span>)u / v;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">    sort(a, a + n, greater&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        Q.push(a[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> len = getMax() + (i - <span class="number">1</span>) * q;</span><br><span class="line">        <span class="comment">//Q.pop();</span></span><br><span class="line">        <span class="keyword">if</span> (!(i % t))</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; len &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">        <span class="keyword">int</span> len1 = <span class="built_in">floor</span>(len * p) - (i - <span class="number">1</span>) * q;</span><br><span class="line">        <span class="keyword">int</span> len2 = len - <span class="built_in">floor</span>(len * p) - (i - <span class="number">1</span>) * q;</span><br><span class="line">        maxQ.push(max(len1, len2) - q);</span><br><span class="line">        minQ.push(min(len1, len2) - q);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">1</span>, ans;</span><br><span class="line">    <span class="keyword">while</span> (ans = getMax()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ans == <span class="number">1</span> &lt;&lt; <span class="number">30</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span> (!(i % t))</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; ans + q * m &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NOIp2016 </tag>
            
            <tag> 堆 </tag>
            
            <tag> 队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【洛谷10月月赛R2·浴谷八连测R3 -Chtholly-】T1 浮游大陆的68号岛</title>
      <link href="/2017/10/21/%E3%80%90%E6%B4%9B%E8%B0%B710%E6%9C%88%E6%9C%88%E8%B5%9BR2%C2%B7%E6%B5%B4%E8%B0%B7%E5%85%AB%E8%BF%9E%E6%B5%8BR3-Chtholly-%E3%80%91T1-%E6%B5%AE%E6%B8%B8%E5%A4%A7%E9%99%86%E7%9A%8468%E5%8F%B7%E5%B2%9B/"/>
      <url>/2017/10/21/%E3%80%90%E6%B4%9B%E8%B0%B710%E6%9C%88%E6%9C%88%E8%B5%9BR2%C2%B7%E6%B5%B4%E8%B0%B7%E5%85%AB%E8%BF%9E%E6%B5%8BR3-Chtholly-%E3%80%91T1-%E6%B5%AE%E6%B8%B8%E5%A4%A7%E9%99%86%E7%9A%8468%E5%8F%B7%E5%B2%9B/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.luogu.org/problemnew/show/3932" target="_blank" rel="noopener">【题目链接】</a></p><h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p>有$n$个仓库，每个仓库有$x_{i}$个货物，第$i$个仓库与第$i+1$个仓库之间的距离为$d_{i}$。储物点$i$的东西要运到储物点$j$，代价为$x \times dist\left( i,j\right)$，其中$dist\left( i,j\right)$为仓库$i$和$j$之间的距离。</p><a id="more"></a><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>直接上正解吧，首先求出每个仓库的位置$x_{i}$。对于每次询问，我们分成三种情况，分别为：</p><ol><li><p>目标仓库在区间的左边</p><p>$ans=b_{l}\cdot \left( x_{l}-x\right)+b_{l+1}\cdot \left( x_{l+1}-x\right)+…+b_{r}\cdot \left( x_{r}-x\right)$</p><p>$ans=\sum b_{i}x_{i}-x\sum b_{i}$</p></li><li><p>目标仓库在区间的右边</p><p>$ans=x\sum b_{i}-\sum b_{i}x_{i}$</p></li><li><p>目标仓库在区间中间</p><p>把区间分成左右两个部分，然后分别计算。</p></li></ol><p>需要预处理三组前缀和，分别为$x_{i},b_{i},b_{i}x_{i}$。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MOD = <span class="number">19260817</span>; <span class="comment">//十九大还没开完呢，就这么暴力</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">200000</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line">LL pos[MAXN], weight[MAXN], pos_2[MAXN]; <span class="comment">//pos为bixi，weight为bi，pos_2为xi</span></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//freopen("in.txt", "r", stdin);</span></span><br><span class="line">    <span class="comment">//freopen("out.txt", "w", stdout);</span></span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">int</span> d;</span><br><span class="line">    pos[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    pos_2[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; d; <span class="comment">//处理前缀和</span></span><br><span class="line">        pos[i] = (pos[i - <span class="number">1</span>] + d) % MOD; <span class="comment">//各种膜，能膜的地方就膜</span></span><br><span class="line">        pos_2[i] = (pos_2[i - <span class="number">1</span>] + d) % MOD;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> b;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; b;</span><br><span class="line">        weight[i] = (weight[i - <span class="number">1</span>] + b) % MOD;</span><br><span class="line">        pos[i] = ((pos[i] * b) % MOD + pos[i - <span class="number">1</span>]) % MOD;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> x, l, r;</span><br><span class="line">    LL ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; x &gt;&gt; l &gt;&gt; r;</span><br><span class="line">        <span class="keyword">if</span> (x &lt;= l)</span><br><span class="line">        &#123;</span><br><span class="line">            ans = ((pos[r] - pos[l - <span class="number">1</span>]) - (pos_2[x] * (weight[r] - weight[l - <span class="number">1</span>])) % MOD) % MOD;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (x &gt; r)</span><br><span class="line">        &#123;</span><br><span class="line">            ans = (pos_2[x] * (weight[r] - weight[l - <span class="number">1</span>]) % MOD - (pos[r] - pos[l - <span class="number">1</span>])) % MOD;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            ans = ((pos_2[x] * (weight[x] - weight[l - <span class="number">1</span>]) % MOD - (pos[x] - pos[l - <span class="number">1</span>])) + ((pos[r] - pos[x - <span class="number">1</span>]) - pos_2[x] * (weight[r] % MOD - weight[x - <span class="number">1</span>]))) % MOD;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (ans &lt; <span class="number">0</span>) <span class="comment">//这里注意特判一下，如果ans&lt;0，则需要加上一个长者的生日</span></span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; ans + MOD &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Luogu </tag>
            
            <tag> 前缀和 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【UVa-10129】Play on Words</title>
      <link href="/2017/10/09/%E3%80%90UVa-10129%E3%80%91Play-on-Words/"/>
      <url>/2017/10/09/%E3%80%90UVa-10129%E3%80%91Play-on-Words/</url>
      
        <content type="html"><![CDATA[<p><a href="https://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;page=show_problem&amp;problem=1070" target="_blank" rel="noopener">【题目链接】</a></p><h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p>第一行有一个正整数$T$,表示有$T$组测试数据；每组测试数据的第一行有一个正整数$n$，表示有$n$个单词，接下来输入$n$个单词，每个单词最多包含$1000$个小写字母，输入中可以有重复单词。是否可以把这些单词排成一个序列，使得每个单词的第一个字母和上一个单词的最后一个字母相同（例如acm， malform， mouse）。如果可以输出<strong>Ordering is possible.</strong>，否则输出<strong>The door cannot be opened.</strong>。</p><a id="more"></a><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>先来讲讲有关图论的知识。</p><p>在无向图中，能否从图中的一个结点出发走出一条道路，每边恰好经过一次，这样的路线称为<code>欧拉道路（Eulerian path）</code>，也可以形象地成为“一笔画”。<code>无向图</code>中存在欧拉路径的条件为：<code>图是连通的，且最多只有两个结点的度为奇数（又称奇点）</code>。如果有两个奇点，则必须从其中的一个奇点出发，另一个奇点终止；如果奇点不存在。则可以从任一点出发，最终回到起点（称为<code>欧拉回路</code>）。<code>有向图</code>中，存在欧拉路的条件为：<code>最多只能有两个点的出度不等于入度</code>，而且必须其中一个点的出度比入度大$1$（作为终点），另一个点的入度比出度大$1$（作为起点）。还有一个前提条件：<code>在忽略边的方向后，图必须是连通的</code>。下面是程序，它同时适用于欧拉道路和回路。如果需要打印欧拉道路，在主程序调用时，参数必须是道路的起点。另外，打印的顺序是逆序的，因此在调用这份代码时，应该把<code>printf</code>语句改成一条<code>push</code>语句，把边$(u,v)$压入一个栈内。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">euler</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> v = <span class="number">0</span>; v &amp;lt; n; v++)</span><br><span class="line"><span class="keyword">if</span> (G[u][v] &amp;amp;&amp;amp; !vis[u][v]) &#123;</span><br><span class="line">vis[u][v] = vis[v][u] = <span class="number">1</span>;</span><br><span class="line">euler(v);</span><br><span class="line"><span class="built_in">printf</span>(&amp;quot;%d %d\n&amp;quot;, u, v);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面进入正题。我们可以把每个单词的首尾两个字母看成结点，用一条边把它们连起来。则问题有解，当且仅当图中有<code>欧拉路径</code>。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> &amp;lt;bits/stdc++.h&amp;gt;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">100010</span>;</span><br><span class="line"><span class="built_in">string</span> s;</span><br><span class="line"><span class="keyword">int</span> T, n, degree[<span class="number">30</span>][<span class="number">2</span>];</span><br><span class="line"><span class="keyword">bool</span> G[<span class="number">30</span>][<span class="number">30</span>], vis[<span class="number">30</span>];</span><br><span class="line"><span class="built_in">set</span>&amp;lt;<span class="keyword">char</span>&amp;gt; char_cnt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;<span class="comment">//DFS查找结点个数</span></span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">1</span>;</span><br><span class="line">vis[u] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> v = <span class="number">0</span>; v &amp;lt; <span class="number">26</span>; v++) &#123;</span><br><span class="line"><span class="keyword">if</span> (!vis[v] &amp;amp;&amp;amp; G[u][v])</span><br><span class="line">ans += dfs(v);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span> &amp;gt;&amp;gt; T;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &amp;lt; T; i++) &#123;</span><br><span class="line"><span class="built_in">cin</span> &amp;gt;&amp;gt; n;</span><br><span class="line"><span class="built_in">memset</span>(G, <span class="number">0</span>, <span class="keyword">sizeof</span>(G));</span><br><span class="line"><span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span>(vis));</span><br><span class="line"><span class="built_in">memset</span>(degree, <span class="number">0</span>, <span class="keyword">sizeof</span>(degree));</span><br><span class="line">char_cnt.clear();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &amp;lt; n; j++) &#123;</span><br><span class="line"><span class="built_in">cin</span> &amp;gt;&amp;gt; s;</span><br><span class="line">G[s[<span class="number">0</span>] - &amp;#<span class="number">39</span>;a&amp;#<span class="number">39</span>;][s[s.size() - <span class="number">1</span>] - &amp;#<span class="number">39</span>;a&amp;#<span class="number">39</span>;] = <span class="literal">true</span>; <span class="comment">//在判断图的连通性时是无向图，所以要反向存一次边</span></span><br><span class="line">G[s[s.size() - <span class="number">1</span>] - &amp;#<span class="number">39</span>;a&amp;#<span class="number">39</span>;][s[<span class="number">0</span>] - &amp;#<span class="number">39</span>;a&amp;#<span class="number">39</span>;] = <span class="literal">true</span>;</span><br><span class="line">degree[s[<span class="number">0</span>] - &amp;#<span class="number">39</span>;a&amp;#<span class="number">39</span>;][<span class="number">0</span>]++;<span class="comment">//入度++</span></span><br><span class="line">degree[s[s.size() - <span class="number">1</span>] - &amp;#<span class="number">39</span>;a&amp;#<span class="number">39</span>;][<span class="number">1</span>]++;<span class="comment">//出度++</span></span><br><span class="line">char_cnt.insert(s[<span class="number">0</span>]);<span class="comment">//统计有多少个结点，用set</span></span><br><span class="line">char_cnt.insert(s[s.size() - <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">bool</span> isDegree = <span class="literal">true</span>, isLiantong = <span class="literal">true</span>;  </span><br><span class="line"><span class="comment">//isDegree用于标记结点的入度和出度是否符合存在欧拉路的条件</span></span><br><span class="line"><span class="comment">//isLiantong用于标记图是否连通</span></span><br><span class="line"><span class="keyword">if</span> (dfs(s[<span class="number">0</span>] - &amp;#<span class="number">39</span>;a&amp;#<span class="number">39</span>;) != char_cnt.size())<span class="comment">//通过判断结点个数以判断是否连通</span></span><br><span class="line">isLiantong = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">int</span> notSame = <span class="number">0</span>, notSameChar[<span class="number">2</span>];<span class="comment">//记录b出度不等于入度的结点的信息</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &amp;lt; <span class="number">26</span>; j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (degree[j][<span class="number">0</span>] != degree[j][<span class="number">1</span>]) &#123;</span><br><span class="line"><span class="keyword">if</span> ((++notSame) &amp;gt; <span class="number">2</span>) &#123;</span><br><span class="line">isDegree = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">notSameChar[notSame - <span class="number">1</span>] = j;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (notSame == <span class="number">2</span> &amp;amp;&amp;amp; (<span class="built_in">abs</span>(degree[notSameChar[<span class="number">0</span>]][<span class="number">0</span>] - degree[notSameChar[<span class="number">0</span>]][<span class="number">1</span>]) != <span class="number">1</span> || <span class="built_in">abs</span>(degree[notSameChar[<span class="number">1</span>]][<span class="number">0</span>] - degree[notSameChar[<span class="number">1</span>]][<span class="number">1</span>]) != <span class="number">1</span>))</span><br><span class="line"><span class="comment">//判断是否只有两个点的出度不等于入度且出度和入度相差1</span></span><br><span class="line">isDegree = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">if</span> (isDegree &amp;amp;&amp;amp; isLiantong)</span><br><span class="line"><span class="built_in">cout</span> &amp;lt;&amp;lt; &amp;quot;Ordering is possible.&amp;quot; &amp;lt;&amp;lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">cout</span> &amp;lt;&amp;lt; &amp;quot;The door cannot be opened.&amp;quot; &amp;lt;&amp;lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><p>[1] 刘汝佳. 算法竞赛入门经典.第2版[M]. 清华大学出版社, 2014.</p>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> UVa </tag>
            
            <tag> 图论 </tag>
            
            <tag> 欧拉回路 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【UVa-10305】Ordering Tasks</title>
      <link href="/2017/10/06/%E3%80%90UVa-10305%E3%80%91Ordering-Tasks/"/>
      <url>/2017/10/06/%E3%80%90UVa-10305%E3%80%91Ordering-Tasks/</url>
      
        <content type="html"><![CDATA[<p><a href="https://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;page=show_problem&amp;problem=1246" target="_blank" rel="noopener">【题目链接】</a></p><h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p>给定$1\leq n\leq 100$和$m$，表示有$n$个任务，所有任务之间有$m$个关系，接下来$m$行，每行包含两个整数$i$，$j$，表示在进行$j$任务之前必须完成$i$任务。</p><a id="more"></a><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>把每个任务看成一个点，“前提任务”看成有向边，则得到了一个有向图，我们把这个有向图叫做<strong>AOV网</strong>（顶点活动网，<b>A</b>ctivity <b>O</b>n <b>V</b>ertex  network）。这样，我们的任务实际上就是把图中的所有节点排序，使得每一条有向边$(u,v)$对应的$u$都排在$v$的前面。在图论中，这个问题成为<strong>拓扑排序</strong>。</p><p>不难发现：如果这个图中存在有向环，则不存在拓扑排序，反之则存在。不包含任何有向环的有向图成为<strong>有向无环图</strong>（<b>D</b>irected <b>A</b>cyclic <b>G</b>raph, <b>DAG</b>）。可以借助DFS完成拓扑排序：在完成一个结点后把它加在当前拓扑序的首部。</p><p>为什么是加到首部呢？因为在DFS的时候，假设当前节点为最后一个，即该结点出度为0，那么就可以把它放到拓扑序的首部（序列中只有这一个结点），然后回溯。在回溯的过程中，依次确定结点。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">110</span>;</span><br><span class="line"><span class="keyword">int</span> c[MAXN], G[MAXN][MAXN];</span><br><span class="line"><span class="keyword">int</span> ans[MAXN];</span><br><span class="line"><span class="keyword">int</span> t, n, m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    c[u] = <span class="number">-1</span>;<span class="comment">//-1表示正在访问</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> v = <span class="number">1</span>; v &lt;= n; v++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (G[u][v])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (c[v] == <span class="number">-1</span>)<span class="comment">//如果当前节点正在被访问，说明有环</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (!c[v] &amp;&amp; !dfs(v)) <span class="comment">//如果没有被访问过且接下来有环，因为只有出现了环才会return false，这里利用了&amp;&amp;是“短路”运算符的性质</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    c[u] = <span class="number">1</span>;</span><br><span class="line">    ans[--t] = u;<span class="comment">//把当前结点加在拓扑序的首部</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">toposort</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    t = n;</span><br><span class="line">    <span class="keyword">int</span>  i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">if</span> (!c[i] &amp;&amp; !dfs(i))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m &amp;&amp; n + m)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(G, <span class="literal">false</span>, <span class="keyword">sizeof</span>(G));</span><br><span class="line">        <span class="built_in">memset</span>(c, <span class="number">0</span>, <span class="keyword">sizeof</span>(c));</span><br><span class="line">        <span class="keyword">int</span> i, a, b;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b;</span><br><span class="line">            G[a][b] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (toposort())</span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++)</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; ans[i] &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; ans[n - <span class="number">1</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><p>[1] 刘汝佳. 算法竞赛入门经典.第2版[M]. 清华大学出版社, 2014.</p>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> UVa </tag>
            
            <tag> 图论 </tag>
            
            <tag> 拓扑排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2017/10/05/Hello-World-1/"/>
      <url>/2017/10/05/Hello-World-1/</url>
      
        <content type="html"><![CDATA[<p>一开始是没想过要做一个Blog的，但是学校的老师让我们开一个Blog，写题解，还要搞一个<a href="http://www.cnblogs.com/nnszoi/p/7602220.html" target="_blank" rel="noopener">整合</a>……于是我就想做一个Blog，正好可以写一些文章什么的。</p><p>老师推荐用<strong>博客园</strong>或<strong>CSDN</strong>， 但觉得界面太恶心，于是就打算自己写框架挂在<strong>GitHub Pages</strong>上。</p><p>之前做过一个网站，本来是打算沿用<strong>Bootstrap</strong>框架的，但是沉迷<strong>Material Design</strong>，于是上网找了找，决定使用<strong>Materialize</strong>框架。然后评论系统还是用之前搭的那个网站的<strong>DISQUS</strong>，但是需要<strong>科学上网</strong>……</p><p>既然是<strong>Hello World</strong>， 那就放一段<strong>Hello World</strong>的代码吧。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Hello, World"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2017-10-29-Update"><a href="#2017-10-29-Update" class="headerlink" title="2017-10-29 Update"></a>2017-10-29 Update</h3><p>这次加入了一个博客生成器——<strong>Jekyll</strong>，每次只需在特定文件夹里写好<strong>.md文件</strong>，就可以根据模板中的设置，生成对应的静态<strong>.html文件</strong>，所以只用专注于文章，而不用把注意力放在HTML上，写博客的速度大大加快。</p>]]></content>
      
      
      <categories>
          
          <category> Daily </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
